{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#_1","title":"","text":"<p>Metanno is a Python library built on top of the Pret framework for building dynamic, customizable annotation interfaces.</p> <p>Who is it for? Research groups, clinical NLP and biomedical teams, data labeling squads, and anyone who wants custom and interactive annotation tools without wrestling with JavaScript.</p> <p>Metanno currently focuses on text and images with richly structured entities. Its goals are:</p> <ul> <li>Modularity: show your data from multiple synchronized angles. For example, highlight entities over text or images while editing the same rows in a table.</li> <li>Python\u2011first UI: write the entire app in Python; it renders to a fast React UI under the hood.</li> <li>Interactivity: handle annotations as plain Python objects at any time, so you can create, inspect, and transform them programmatically.</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#annotate-anything","title":"Annotate anything","text":"<p>In addition to the Pret ecosystem component suite, Metanno provides components for common annotation views:</p> <ul> <li>AnnotatedText: display text with highlighted, nestable spans</li> <li>AnnotatedImage: draw shapes (boxes, polygons, etc.) over images.</li> <li>Table: an editable, filterable spreadsheet\u2011style grid for inspecting and editing annotations.</li> </ul> <p>You can compose these views of the same underlying annotations to get a better grasp of the data you are annotating or inspecting.</p>"},{"location":"#run-it-your-way","title":"Run it your way","text":"<p>Use Metanno in two modes:</p> <ul> <li>Standalone app: run a server and use it in your browser.</li> <li>JupyterLab widgets: embed components directly in notebooks, with no extra ports or separate server process.</li> </ul> <p>Develop and test in a notebook. If you prefer, you can also run it as a standalone app.</p>"},{"location":"#easy-setup","title":"Easy setup","text":"<pre><code>pip install metanno\n</code></pre> <p>Unlike other alternatives, Metanno requires no additional ports and no separate server process when used in JupyterLab. Write your app in Python and benefit from a fast React front end under the hood.</p>"},{"location":"#interactive-and-customizable-by-design","title":"Interactive and customizable by design","text":"<ul> <li>Inspect and edit application state directly from Python.</li> <li>Update the UI from Python; execute a notebook cell to see changes immediately.</li> <li>Register event handlers for clicks, hovers, keystrokes, and more.</li> </ul>"},{"location":"#why-another-annotation-software","title":"Why another annotation software?","text":"<p>Tool choice shapes both the annotation scheme and the workflow. In many out\u2011of\u2011the\u2011box tools, tasks like annotating implicit or document\u2011level entities, working across multiple documents at once, or coordinating multiple views can be difficult or unsupported. There are many available solutions (see Neves et al.). However,  most of these are either proprietary, poorly adapted to document or multi-document annotation, require a complex installation that is not compatible with existing strict remote computing environments, or are difficult to customize.</p> <p>Metanno takes a different approach: a modular, Python\u2011first framework that adapts to your schema and to your annotation process, instead of forcing you into fixed layers or rigid UIs.</p>"},{"location":"#demo","title":"Demo","text":"<p>See the demos.</p> <p>Below is a small example that lets you annotate text spans and view them in a synchronized table. Select spans to add them; hold Shift (also labeled Maj on some keyboards) while selecting to delete overlapping spans.</p> Show code <pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import AnnotatedText\n\nstate = create_store([\n    {\"text\": \"soir\", \"begin\": 3, \"end\": 7, \"id\": \"s-3-7\", \"label\": \"ENT\"},\n    {\"text\": \"Charlie\", \"begin\": 59, \"end\": 66, \"id\": \"s-59-66\", \"label\": \"ENT\"},\n])\n\ntext = (\"Le soir, apr\u00e8s avoir mang\u00e9 sa soupe aux choux noy\u00e9e \"\n        \"d\u2019eau, Charlie allait toujours dans la chambre de ses \"\n        \"quatre grands-parents pour \u00e9couter leurs histoires, \"\n        \"et pour leur souhaiter bonne nuit.\\n\"\n        \"Chacun d\u2019eux avait plus de quatre-vingt-dix ans. Ils \"\n        \"\u00e9taient frip\u00e9s comme des pruneaux secs, ossus comme \"\n        \"des squelettes et, toute la journ\u00e9e, jusqu\u2019\u00e0 l\u2019apparition \"\n        \"de Charlie, ils se pelotonnaient dans leur lit, deux de \"\n        \"chaque c\u00f4t\u00e9, coiff\u00e9s de bonnets de nuit qui leur tenaient \"\n        \"chaud, passant le temps \u00e0 ne rien faire.\")\n\n\n@component\ndef App():\n    view_state = use_store_snapshot(state)\n\n    @use_event_callback\n    def on_select(spans, mod_keys):\n        if \"Shift\" in mod_keys:\n            # Delete overlapped spans if the user holds Shift\n            state[:] = [\n                x\n                for x in state\n                if any((s['begin'] &gt;= x['end'] or s['end'] &lt;= x['begin']) for s in spans)\n            ]\n        else:\n            state.extend(\n                [{**s, \"id\": f\"s-{s['begin']}-{s['end']}\", \"text\": text[s['begin']:s['end']], \"label\": \"ENT\"} for s in spans]\n            )\n\n    return AnnotatedText(\n        text=text,\n        spans=view_state,\n        annotation_styles={\"ENT\": {\"color\": \"lightblue\"}},\n        on_mouse_select=on_select,\n    )\n\n\nApp()\n</code></pre> <p>The annotations are reflected in the table below. Both views stay in sync because they share the same state (<code>state</code>).</p> Show code <pre><code># \u2191 Complete the code above with the following snippet \u2191\nfrom pret import component, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import Table\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"begin\", \"kind\": \"text\", \"name\": \"begin\", \"filterable\": True},\n    {\"key\": \"end\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True},\n    {\"key\": \"label\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        view_state[row_idx][col] = new_value\n\n    for x in state:\n        x.setdefault(\"label\", \"ENT\")  # Ensure all rows have a label\n\n    view_state = use_store_snapshot(state)\n    return Table(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#as-a-user","title":"As a user","text":"<p>A simple pip installation should be enough to install Metanno both as a standalone web app framework and as a JupyterLab extension:</p> <pre><code>pip install metanno\n</code></pre> <p>However, depending on your Jupyter setup, especially for shared JupyterHub servers, a user-level installation might be necessary. In this case, run instead</p> <pre><code>pip install metanno --user\n</code></pre> <p>Refresh your JupyterLab page to load the installed javascript files, et voil\u00e0.</p>"},{"location":"installation/#as-a-contributor","title":"As a contributor","text":"<p>If you want to contribute to Metanno, you should have a programming environment:</p> <ul> <li>Python 3.7 or later, with pip and hatch installed</li> <li>Node.js 20 or later (you can use nvm to easily install and manage Node.js versions)</li> <li>JupyterLab 3 (the built extension will be compatible with JupyterLab 4)</li> <li>Various web browsers for testing (e.g., Chrome, Firefox, Safari)</li> <li>A Git client to clone the repository and manage your changes</li> </ul> <pre><code>git clone https://github.com/percevalw/metanno.git\ncd metanno\n</code></pre> <p>Then, create a new branch for your changes:</p> <pre><code>git checkout -b my-feature-branch\n</code></pre> <p>Create (optional) virtual env and install all development deps. Install the package in editable mode with development dependencies:</p> <pre><code>yarn install\npip install -e . --group dev  #(1)!\nyarn playwright install --with-deps # browsers for UI tests\n</code></pre> <ol> <li>or <code>uv pip install -e . --group dev</code> with uv</li> </ol>"},{"location":"installation/#running-the-ui-tests","title":"Running the UI tests","text":"<p>Metanno uses playwright to test the JupyterLab extension (which should cover most of the app features). You can run the tests to ensure everything is working correctly.</p> <pre><code>sh tests/jupyter/run.sh #(1)!\n</code></pre> <ol> <li>or <code>uv run sh tests/jupyter/run.sh</code> with uv</li> </ol>"},{"location":"installation/#building-the-documentation","title":"Building the documentation","text":"<p>The documentation is built with MkDocs and MkDocs Material theme, along with quite a few customizations. To build the documentation, you can use the following command:</p> <pre><code>pip install -e . --group docs  #(1)!\nmkdocs serve  #(2)!\n</code></pre> <ol> <li>or <code>uv pip install -e . --group docs</code> with uv</li> <li>or <code>uv run mkdocs serve</code> with uv</li> </ol> <ol></ol>"},{"location":"components/","title":"Building Blocks of Metanno","text":"<p>This page provides an overview of the base components available in Metanno.</p> Component Description AnnotatedText View and interact with a text with optional annotations. AnnotatedImage View and interact with an image with optional annotations. Table View and interact with a table"},{"location":"components/annotated-image/","title":"AnnotatedImage","text":""},{"location":"components/annotated-image/#pret.ui.metanno.AnnotatedImage","title":"AnnotatedImage","text":"<p>An interactive image viewer that supports drawing, selecting, and styling geometric shapes (polygons, rectangles, points...) as annotations.</p> <p>Under the hood, we use Konva to render the image and its annotations.</p>"},{"location":"components/annotated-image/#pret.ui.metanno.AnnotatedImage--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import AnnotatedImage\nimport time\n\n# Reactive store holding the annotation list\nimg_state = create_store([\n    {\n        \"id\": \"1\",\n        \"type\": \"polygon\",\n        \"points\": [10, 10, 50, 20],\n        \"label\": \"OBJ\",\n        \"style\": \"primary\",\n    }\n])\n\n# Style preset referenced from the annotation above\nimg_annotation_styles = {\n    \"primary\": {\n        \"strokeColor\": \"red\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"rgba(255,0,0,0.5)\",\n        \"labelPosition\": \"center\",\n        \"align\": \"center\",\n        \"verticalAlign\": \"top\",\n    },\n    \"secondary\": {\n        \"strokeColor\": \"blue\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"#0000ff80\",\n        \"textColor\": \"white\",\n    }\n}\n\n@component\ndef MyImage():\n    tracked_state = use_store_snapshot(img_state)\n\n    @use_event_callback\n    def on_mouse_select(modkeys, shapes):\n        # Toggle 'mouseSelected' flag\n        for shp in shapes:\n            img_state.append({\n                \"id\": str(time.time()),\n                \"points\": shp[\"points\"],\n                \"label\": \"OBJ\",\n                \"style\": \"primary\",\n            })\n\n    @use_event_callback\n    def on_click(shape_idx, modkeys):\n        if shape_idx is None:\n            img_state.clear()\n        else:\n            old_style = img_state[shape_idx].get(\"style\", \"primary\")\n            new_style = \"secondary\" if old_style == \"primary\" else \"primary\"\n            img_state[shape_idx][\"style\"] = new_style\n\n    return AnnotatedImage(\n        image=\"https://picsum.photos/400/300\",\n        annotations=tracked_state,\n        annotation_styles=img_annotation_styles,\n        on_mouse_select=on_mouse_select,\n        on_click=on_click,\n    )\n\nMyImage()\n</code></pre>"},{"location":"components/annotated-image/#pret.ui.metanno.AnnotatedImage--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>annotations</code> <p>List of annotation objects drawn on top of the image. Each annotation must contain the geometric <code>type</code> and <code>points</code> fields (defining the shape) plus optional metadata such as:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Human-readable text shown next to the shape.</li> <li><code>style</code>: Key that looks up visual properties in <code>annotation_styles</code>.</li> <li><code>selected</code> / <code>highlighted</code> / <code>mouseSelected</code>: Booleans used by the   component when rendering interaction state.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>annotation_styles</code> <p>Named style presets referenced by the <code>style</code> field of an annotation.  Each preset may define properties such as stroke color, fill color, opacity, font size, and label alignment, using the following properties:</p> <ul> <li><code>strokeColor</code> (str): Color of the shape's stroke (e.g. <code>\"#ff0000\"</code>).</li> <li><code>strokeWidth</code> (int): Width of the shape's stroke in pixels.</li> <li><code>fillColor</code> (str): Background color of the shape (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>opacity</code> (float): Opacity of the shape's fill (0.0 to 1.0).</li> <li><code>shape</code> (str): Shape type, e.g. <code>\"polygon\"</code>, <code>\"rectangle\"</code>, <code>\"circle\"</code>, etc.</li> <li><code>fontSize</code> (int): Font size for the label text.</li> <li><code>align</code> (\"left\" | \"center\" | \"right\"): Horizontal alignment of the label text.</li> <li><code>verticalAlign</code> (\"top\" | \"middle\" | \"bottom\"): Vertical alignment of the label text.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>image</code> <p>Source URL or base-64 data URI of the image to annotate.</p> <p> TYPE: <code>str</code> </p> <code>mouse_selection</code> <p>Temporary shapes being drawn by the user while the mouse button is held down.  Supplied back to <code>on_mouse_select</code> when the gesture ends.</p> <p> TYPE: <code>Any</code> </p> <code>style</code> <p>Inline CSS-compatible style overrides for the root element of the component.</p> <p> TYPE: <code>Any</code> </p> <code>actions</code> <p>Optional imperative handles (e.g. <code>actions[\"scroll_to_shape\"](idx)</code>) that the parent may call.  Reserved for future expansion.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>React key for stable reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click</code> <p>Invoked when the user clicks on an existing shape.</p> <ul> <li><code>shape_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 List of pressed modifier keys (e.g. <code>[\"Shift\"]</code>)</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_key_press</code> <p>Invoked when the component has focus and the user presses a key.</p> <ul> <li><code>key</code> \u2013 The key name (<code>\"Escape\"</code>, <code>\"Delete\"</code> \u2026)</li> <li><code>modkeys</code> \u2013 Concurrently pressed modifier keys</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_mouse_enter_shape</code> <p>Hover callbacks fired when the mouse pointer enters or leaves a shape.</p> <p> TYPE: <code>Any</code> </p> <code>on_mouse_select</code> <p>Fired after the user completes a drag selection.</p> <ul> <li><code>modkeys</code> \u2013 Modifier keys pressed during selection</li> <li><code>shapes</code> \u2013 All shapes inside the lasso / rectangle</li> </ul> <p> TYPE: <code>Any</code> </p>"},{"location":"components/annotated-text/","title":"AnnotatedText","text":""},{"location":"components/annotated-text/#pret.ui.metanno.AnnotatedText","title":"AnnotatedText","text":"<p>The <code>AnnotatedText</code> is a rich text viewer that supports span-level annotations, nested token highlights, and various user event callbacks.</p>"},{"location":"components/annotated-text/#pret.ui.metanno.AnnotatedText--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback, use_state\nfrom pret.ui.metanno import AnnotatedText\nfrom pret.ui.joy import Button, Box\n\ntxt = (\n    \"Metanno brings annotation components to Pret\\n\"\n    \"to build tailored annotation tools.\"\n)\n\n# One span covering the word \u201cMetanno\u201d\nspans = create_store([{\n    \"id\": f\"span-0-7\",\n    \"begin\": 0,\n    \"end\": 7,\n    \"label\": \"OBJ\",\n    \"highlighted\": False,\n}])\n\ntxt_annotation_styles = create_store({\n    \"OBJ\": {\n        \"color\": \"red\",\n        \"shape\": \"underline\",\n    }\n})\n\n@component\ndef MyText():\n    tracked_spans = use_store_snapshot(spans)\n    tracked_styles = use_store_snapshot(txt_annotation_styles)\n\n    @use_event_callback\n    def handle_select(ranges, modkeys):\n        for sp in ranges:\n            spans.extend([\n                {\n                    \"id\": f\"span-{sp['begin']}-{sp['end']}\",\n                    \"begin\": sp[\"begin\"],\n                    \"end\": sp[\"end\"],\n                    \"label\": \"OBJ\",\n                }\n            ])\n\n    def on_mouse_enter_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = True\n\n    def on_mouse_leave_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = False\n\n    def on_span_style_change():\n        old_style = txt_annotation_styles[\"OBJ\"][\"shape\"]\n        new_style = \"box\" if old_style == \"underline\" else \"underline\"\n        txt_annotation_styles[\"OBJ\"][\"shape\"] = new_style\n\n    return Box(\n        Button(\"Change style\", on_click=on_span_style_change),\n        Button(\"Remove annotations\", on_click=lambda: spans.clear()),\n        AnnotatedText(\n            text=txt,\n            spans=tracked_spans,\n            annotation_styles=tracked_styles,\n            on_mouse_select=handle_select,\n            on_mouse_enter_span=on_mouse_enter_span,\n            on_mouse_leave_span=on_mouse_leave_span,\n            style={\"gridColumn\": \"1 / -1\"},\n        ),\n        sx={\"p\": 1, \"display\": \"grid\", \"gridTemplateColumns\": \"repeat(2, auto)\", \"gap\": 1},\n    )\n\nMyText()\n</code></pre>"},{"location":"components/annotated-text/#pret.ui.metanno.AnnotatedText--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>text</code> <p>Raw text content shown in the viewer.</p> <p> TYPE: <code>str</code> </p> <code>spans</code> <p>Span-level annotations over <code>text</code>.  Each span must include <code>begin</code> and <code>end</code> character offsets, with optional fields:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Category name displayed next to / above the span.</li> <li><code>style</code>: Key referencing <code>annotation_styles</code>.</li> <li><code>selected</code> (bool): styled as selected by the user.</li> <li><code>highlighted</code> (bool): styled as highlighted by the user.</li> </ul> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>annotation_styles</code> <p>Named style presets that control span background color, border, label placement, etc. Each style may define properties such as:</p> <ul> <li><code>color</code> (str): Color of the span. Will be overridden by <code>backgroundColor</code> and <code>borderColor</code>.</li> <li><code>shape</code> (\"underline\" | \"box\"): Visual style of the span.</li> <li><code>backgroundColor</code> (str): Background color of the span (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>borderColor</code> (str): Border color of the span (e.g. <code>\"#000000\"</code>).</li> <li><code>autoNestingLayout</code> (bool): Whether to automatically nest overlapping spans, rather than rendering them on top of each other.</li> </ul> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> <code>mouse_selection</code> <p>Current mouse drag selection expressed as character\u2010offset ranges. Passed to <code>on_mouse_select</code> when the action completes.</p> <p> TYPE: <code>List[Dict[str, int]]</code> </p> <code>style</code> <p>CSS style overrides for the outer element.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>actions</code> <p>Optional imperative helpers (<code>scroll_to_span</code> \u2026, <code>clear_current_mouse_selection</code>).</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>React reconciliation key.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click_span</code> <p>Called when the user clicks on a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_key_press</code> <p>Called when a key is pressed with focus inside the component.</p> <ul> <li><code>key</code> \u2013 Key name</li> <li><code>ranges</code> \u2013 Current selection ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[Dict[str, int]], List[str]], None]</code> </p> <code>on_mouse_enter_span</code> <p>Called when the mouse pointer enters a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the span entered</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_leave_span</code> <p>Called when the mouse pointer leaves a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the span left</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_select</code> <p>Triggered when the user finishes selecting text with the mouse.</p> <ul> <li><code>ranges</code> \u2013 Final list of selected ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[Dict[str, int]], List[str]], None]</code> </p>"},{"location":"components/table/","title":"Table","text":""},{"location":"components/table/#pret.ui.metanno.Table","title":"Table","text":"<p>A component for displaying a table with various features such as filtering, highlighting rows, and handling cell changes.</p>"},{"location":"components/table/#pret.ui.metanno.Table--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import Table\n\ntable_state = create_store([\n    {\"id\": \"1\", \"date\": \"2023-01-01\", \"text\": \"Sample text 1\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"2\", \"date\": \"2023-01-03\", \"text\": \"Sample text 2\", \"type\": \"OTHER\", \"labels\": [\"ready\", \"danger\"]},\n    {\"id\": \"3\", \"date\": \"2023-01-05\", \"text\": \"Sample text 3\", \"type\": \"ENT\", \"labels\": [\"blue\"]},\n    {\"id\": \"4\", \"date\": \"2023-01-07\", \"text\": \"Sample text 4\", \"type\": \"OTHER\", \"labels\": [\"bad\"]},\n    {\"id\": \"5\", \"date\": \"2023-01-09\", \"text\": \"Sample text 5\", \"type\": \"ENT\", \"labels\": []},\n    {\"id\": \"6\", \"date\": \"2023-01-11\", \"text\": \"Sample text 6\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"7\", \"date\": \"2023-01-13\", \"text\": \"Sample text 7\", \"type\": \"FOO\", \"labels\": [\"ready\"]},\n    {\"id\": \"8\", \"date\": \"2023-01-15\", \"text\": \"Sample text 8\", \"type\": \"FOO2\", \"labels\": [\"danger\"]},\n    {\"id\": \"9\", \"date\": \"2023-01-17\", \"text\": \"Sample text 9\", \"type\": \"FOO3\", \"labels\": [\"blue\"]},\n    {\"id\": \"10\", \"date\": \"2023-01-19\", \"text\": \"Sample text 10\", \"type\": \"ENT\", \"labels\": [\"bad\"]},\n    {\"id\": \"11\", \"date\": \"2023-01-21\", \"text\": \"Sample text 11\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"12\", \"date\": \"2023-01-23\", \"text\": \"Sample text 12\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"13\", \"date\": \"2023-01-25\", \"text\": \"Sample text 13\", \"type\": \"OTHER\", \"labels\": [\"danger\"]},\n    {\"id\": \"14\", \"date\": \"2023-01-27\", \"text\": \"Sample text 14\", \"type\": \"FOO2\", \"labels\": [\"blue\"]},\n    {\"id\": \"15\", \"date\": \"2023-01-29\", \"text\": \"Sample text 15\", \"type\": \"FOO3\", \"labels\": [\"bad\"]},\n])\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"date\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True, \"editable\": True},\n    {\"key\": \"type\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\", \"STUFF\", \"FOO\", \"FOO2\", \"FOO3\"]},\n    {\"key\": \"labels\", \"kind\": \"multi-text\", \"name\": \"labels\", \"filterable\": True, \"editable\": True, \"choices\": [\"ready\", \"danger\", \"blue\", \"bad\", \"custom\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        table_state[row_idx][col] = new_value\n\n    view_state = use_store_snapshot(table_state)\n    return Table(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"components/table/#pret.ui.metanno.Table--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>columns</code> <p>The columns to display in the table:</p> <ul> <li><code>key</code>: Unique identifier for the column.</li> <li><code>name</code>: Display name of the column.</li> <li><code>kind</code>: Type of data in the column (e.g., \"text\", \"hyperlink\", \"multi-text\", \"boolean\", ...).</li> <li><code>editable</code>: Whether the column is editable.</li> <li><code>filterable</code>: Whether the column can be filtered.</li> <li><code>choices</code>: Optional list of choices for the column (if applicable).</li> </ul> <p> TYPE: <code>ColumnData</code> </p> <code>filters</code> <p>The current filters applied to the table, mapping column keys to filter values.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>highlighted_rows</code> <p>List of row indices that should be highlighted.</p> <p> TYPE: <code>List[int]</code> </p> <code>row_key</code> <p>The key used to uniquely identify each row in the table.</p> <p> TYPE: <code>str</code> </p> <code>rows</code> <p>The data for each row in the table, where each row is a dictionary mapping column keys to their values.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>actions</code> <p>Actions that can be performed on the table, such as scrolling.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>auto_filter</code> <p>Whether to automatically apply filters as the user types.</p> <p> TYPE: <code>bool</code> </p> <code>input_value</code> <p>The current input value to show in the input field when the user is editing a cell. If undefined, this is automatically handled by the component.</p> <p> TYPE: <code>Union[str, Hyperlink]</code> </p> <code>suggestions</code> <p>List of suggestions to show when the user is typing in the input field.</p> <p> TYPE: <code>List[Any]</code> </p> <code>position</code> <p>The current position of the cursor in the table, including:</p> <ul> <li>row_idx: Index of the row where the cursor is located.</li> <li>col: Key of the column where the cursor is located.</li> <li>mode: Mode of interaction, either \"EDIT\" or \"SELECT\".</li> </ul> <p> TYPE: <code>Position</code> </p> <code>style</code> <p>Custom styles for the table component.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>A unique key for the component instance, used for React's reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_input_change</code> <p>Callback triggered when the input value changes in a cell. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value entered by the user.</li> <li><code>cause</code>: Reason for the change (e.g., \"blur\", \"enter\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_scroll_bottom</code> <p>Callback triggered when the user scrolls to the bottom of the table. Will be called with the following parameters:</p> <ul> <li><code>event</code>: Scroll event or a dictionary indicating if the user is at the bottom.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_cell_change</code> <p>Callback triggered when a cell's value changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value of the cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_click_cell_content</code> <p>Callback triggered when the content of a cell is clicked (like a hyperlink). Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row containing the clicked cell.</li> <li><code>name</code>: Key of the column containing the clicked cell.</li> <li><code>value</code>: Optional value of the clicked cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_filters_change</code> <p>Callback triggered when filters are updated. Will be called with the following parameters:</p> <ul> <li><code>values</code>: Dictionary mapping column keys to filter values.</li> <li><code>column</code>: Key of the column being filtered.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_enter_row</code> <p>Callback triggered when the mouse enters a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_leave_row</code> <p>Callback triggered when the mouse leaves a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_position_change</code> <p>Callback triggered when the cursor position changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>name</code>: Key of the column where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>mode</code>: Interaction mode, either \"EDIT\" or \"SELECT\".</li> <li><code>cause</code>: Reason for the position change (e.g., \"key\", \"blur\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_subset_change</code> <p>Callback triggered when the subset of visible rows changes. Will be called with the following parameters:</p> <ul> <li><code>subset</code>: List of indices representing the new subset of rows.</li> </ul> <p> TYPE: <code>Callable</code> </p>"},{"location":"demos/","title":"Demos","text":"<p>Here are some examples of applications you can build with Metanno.</p> <p> Quaero Explorer</p><p>Explore and edit the Quaero dataset.</p>"},{"location":"demos/quaero-explorer/","title":"Quaero explorer","text":"<pre><code>from examples.quaero import app\n\n\napp(deduplicate=True)\n</code></pre>"},{"location":"reference/metanno/","title":"<code>metanno</code>","text":""},{"location":"reference/metanno/recipes/","title":"<code>metanno.recipes</code>","text":""},{"location":"reference/metanno/recipes/explorer/","title":"<code>metanno.recipes.explorer</code>","text":""},{"location":"reference/pret/ui/metanno/","title":"index.md","text":""},{"location":"reference/pret/ui/metanno/#pretuimetanno","title":"<code>pret.ui.metanno</code>","text":""},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedImage","title":"<code>AnnotatedImage</code>","text":"<p>An interactive image viewer that supports drawing, selecting, and styling geometric shapes (polygons, rectangles, points...) as annotations.</p> <p>Under the hood, we use Konva to render the image and its annotations.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedImage--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import AnnotatedImage\nimport time\n\n# Reactive store holding the annotation list\nimg_state = create_store([\n    {\n        \"id\": \"1\",\n        \"type\": \"polygon\",\n        \"points\": [10, 10, 50, 20],\n        \"label\": \"OBJ\",\n        \"style\": \"primary\",\n    }\n])\n\n# Style preset referenced from the annotation above\nimg_annotation_styles = {\n    \"primary\": {\n        \"strokeColor\": \"red\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"rgba(255,0,0,0.5)\",\n        \"labelPosition\": \"center\",\n        \"align\": \"center\",\n        \"verticalAlign\": \"top\",\n    },\n    \"secondary\": {\n        \"strokeColor\": \"blue\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"#0000ff80\",\n        \"textColor\": \"white\",\n    }\n}\n\n@component\ndef MyImage():\n    tracked_state = use_store_snapshot(img_state)\n\n    @use_event_callback\n    def on_mouse_select(modkeys, shapes):\n        # Toggle 'mouseSelected' flag\n        for shp in shapes:\n            img_state.append({\n                \"id\": str(time.time()),\n                \"points\": shp[\"points\"],\n                \"label\": \"OBJ\",\n                \"style\": \"primary\",\n            })\n\n    @use_event_callback\n    def on_click(shape_idx, modkeys):\n        if shape_idx is None:\n            img_state.clear()\n        else:\n            old_style = img_state[shape_idx].get(\"style\", \"primary\")\n            new_style = \"secondary\" if old_style == \"primary\" else \"primary\"\n            img_state[shape_idx][\"style\"] = new_style\n\n    return AnnotatedImage(\n        image=\"https://picsum.photos/400/300\",\n        annotations=tracked_state,\n        annotation_styles=img_annotation_styles,\n        on_mouse_select=on_mouse_select,\n        on_click=on_click,\n    )\n\nMyImage()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedImage--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>annotations</code> <p>List of annotation objects drawn on top of the image. Each annotation must contain the geometric <code>type</code> and <code>points</code> fields (defining the shape) plus optional metadata such as:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Human-readable text shown next to the shape.</li> <li><code>style</code>: Key that looks up visual properties in <code>annotation_styles</code>.</li> <li><code>selected</code> / <code>highlighted</code> / <code>mouseSelected</code>: Booleans used by the   component when rendering interaction state.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>annotation_styles</code> <p>Named style presets referenced by the <code>style</code> field of an annotation.  Each preset may define properties such as stroke color, fill color, opacity, font size, and label alignment, using the following properties:</p> <ul> <li><code>strokeColor</code> (str): Color of the shape's stroke (e.g. <code>\"#ff0000\"</code>).</li> <li><code>strokeWidth</code> (int): Width of the shape's stroke in pixels.</li> <li><code>fillColor</code> (str): Background color of the shape (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>opacity</code> (float): Opacity of the shape's fill (0.0 to 1.0).</li> <li><code>shape</code> (str): Shape type, e.g. <code>\"polygon\"</code>, <code>\"rectangle\"</code>, <code>\"circle\"</code>, etc.</li> <li><code>fontSize</code> (int): Font size for the label text.</li> <li><code>align</code> (\"left\" | \"center\" | \"right\"): Horizontal alignment of the label text.</li> <li><code>verticalAlign</code> (\"top\" | \"middle\" | \"bottom\"): Vertical alignment of the label text.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>image</code> <p>Source URL or base-64 data URI of the image to annotate.</p> <p> TYPE: <code>str</code> </p> <code>mouse_selection</code> <p>Temporary shapes being drawn by the user while the mouse button is held down.  Supplied back to <code>on_mouse_select</code> when the gesture ends.</p> <p> TYPE: <code>Any</code> </p> <code>style</code> <p>Inline CSS-compatible style overrides for the root element of the component.</p> <p> TYPE: <code>Any</code> </p> <code>actions</code> <p>Optional imperative handles (e.g. <code>actions[\"scroll_to_shape\"](idx)</code>) that the parent may call.  Reserved for future expansion.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>React key for stable reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click</code> <p>Invoked when the user clicks on an existing shape.</p> <ul> <li><code>shape_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 List of pressed modifier keys (e.g. <code>[\"Shift\"]</code>)</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_key_press</code> <p>Invoked when the component has focus and the user presses a key.</p> <ul> <li><code>key</code> \u2013 The key name (<code>\"Escape\"</code>, <code>\"Delete\"</code> \u2026)</li> <li><code>modkeys</code> \u2013 Concurrently pressed modifier keys</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_mouse_enter_shape</code> <p>Hover callbacks fired when the mouse pointer enters or leaves a shape.</p> <p> TYPE: <code>Any</code> </p> <code>on_mouse_select</code> <p>Fired after the user completes a drag selection.</p> <ul> <li><code>modkeys</code> \u2013 Modifier keys pressed during selection</li> <li><code>shapes</code> \u2013 All shapes inside the lasso / rectangle</li> </ul> <p> TYPE: <code>Any</code> </p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.Table","title":"<code>Table</code>","text":"<p>A component for displaying a table with various features such as filtering, highlighting rows, and handling cell changes.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.Table--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import Table\n\ntable_state = create_store([\n    {\"id\": \"1\", \"date\": \"2023-01-01\", \"text\": \"Sample text 1\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"2\", \"date\": \"2023-01-03\", \"text\": \"Sample text 2\", \"type\": \"OTHER\", \"labels\": [\"ready\", \"danger\"]},\n    {\"id\": \"3\", \"date\": \"2023-01-05\", \"text\": \"Sample text 3\", \"type\": \"ENT\", \"labels\": [\"blue\"]},\n    {\"id\": \"4\", \"date\": \"2023-01-07\", \"text\": \"Sample text 4\", \"type\": \"OTHER\", \"labels\": [\"bad\"]},\n    {\"id\": \"5\", \"date\": \"2023-01-09\", \"text\": \"Sample text 5\", \"type\": \"ENT\", \"labels\": []},\n    {\"id\": \"6\", \"date\": \"2023-01-11\", \"text\": \"Sample text 6\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"7\", \"date\": \"2023-01-13\", \"text\": \"Sample text 7\", \"type\": \"FOO\", \"labels\": [\"ready\"]},\n    {\"id\": \"8\", \"date\": \"2023-01-15\", \"text\": \"Sample text 8\", \"type\": \"FOO2\", \"labels\": [\"danger\"]},\n    {\"id\": \"9\", \"date\": \"2023-01-17\", \"text\": \"Sample text 9\", \"type\": \"FOO3\", \"labels\": [\"blue\"]},\n    {\"id\": \"10\", \"date\": \"2023-01-19\", \"text\": \"Sample text 10\", \"type\": \"ENT\", \"labels\": [\"bad\"]},\n    {\"id\": \"11\", \"date\": \"2023-01-21\", \"text\": \"Sample text 11\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"12\", \"date\": \"2023-01-23\", \"text\": \"Sample text 12\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"13\", \"date\": \"2023-01-25\", \"text\": \"Sample text 13\", \"type\": \"OTHER\", \"labels\": [\"danger\"]},\n    {\"id\": \"14\", \"date\": \"2023-01-27\", \"text\": \"Sample text 14\", \"type\": \"FOO2\", \"labels\": [\"blue\"]},\n    {\"id\": \"15\", \"date\": \"2023-01-29\", \"text\": \"Sample text 15\", \"type\": \"FOO3\", \"labels\": [\"bad\"]},\n])\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"date\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True, \"editable\": True},\n    {\"key\": \"type\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\", \"STUFF\", \"FOO\", \"FOO2\", \"FOO3\"]},\n    {\"key\": \"labels\", \"kind\": \"multi-text\", \"name\": \"labels\", \"filterable\": True, \"editable\": True, \"choices\": [\"ready\", \"danger\", \"blue\", \"bad\", \"custom\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        table_state[row_idx][col] = new_value\n\n    view_state = use_store_snapshot(table_state)\n    return Table(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.Table--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>columns</code> <p>The columns to display in the table:</p> <ul> <li><code>key</code>: Unique identifier for the column.</li> <li><code>name</code>: Display name of the column.</li> <li><code>kind</code>: Type of data in the column (e.g., \"text\", \"hyperlink\", \"multi-text\", \"boolean\", ...).</li> <li><code>editable</code>: Whether the column is editable.</li> <li><code>filterable</code>: Whether the column can be filtered.</li> <li><code>choices</code>: Optional list of choices for the column (if applicable).</li> </ul> <p> TYPE: <code>ColumnData</code> </p> <code>filters</code> <p>The current filters applied to the table, mapping column keys to filter values.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>highlighted_rows</code> <p>List of row indices that should be highlighted.</p> <p> TYPE: <code>List[int]</code> </p> <code>row_key</code> <p>The key used to uniquely identify each row in the table.</p> <p> TYPE: <code>str</code> </p> <code>rows</code> <p>The data for each row in the table, where each row is a dictionary mapping column keys to their values.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>actions</code> <p>Actions that can be performed on the table, such as scrolling.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>auto_filter</code> <p>Whether to automatically apply filters as the user types.</p> <p> TYPE: <code>bool</code> </p> <code>input_value</code> <p>The current input value to show in the input field when the user is editing a cell. If undefined, this is automatically handled by the component.</p> <p> TYPE: <code>Union[str, Hyperlink]</code> </p> <code>suggestions</code> <p>List of suggestions to show when the user is typing in the input field.</p> <p> TYPE: <code>List[Any]</code> </p> <code>position</code> <p>The current position of the cursor in the table, including:</p> <ul> <li>row_idx: Index of the row where the cursor is located.</li> <li>col: Key of the column where the cursor is located.</li> <li>mode: Mode of interaction, either \"EDIT\" or \"SELECT\".</li> </ul> <p> TYPE: <code>Position</code> </p> <code>style</code> <p>Custom styles for the table component.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>A unique key for the component instance, used for React's reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_input_change</code> <p>Callback triggered when the input value changes in a cell. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value entered by the user.</li> <li><code>cause</code>: Reason for the change (e.g., \"blur\", \"enter\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_scroll_bottom</code> <p>Callback triggered when the user scrolls to the bottom of the table. Will be called with the following parameters:</p> <ul> <li><code>event</code>: Scroll event or a dictionary indicating if the user is at the bottom.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_cell_change</code> <p>Callback triggered when a cell's value changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value of the cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_click_cell_content</code> <p>Callback triggered when the content of a cell is clicked (like a hyperlink). Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row containing the clicked cell.</li> <li><code>name</code>: Key of the column containing the clicked cell.</li> <li><code>value</code>: Optional value of the clicked cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_filters_change</code> <p>Callback triggered when filters are updated. Will be called with the following parameters:</p> <ul> <li><code>values</code>: Dictionary mapping column keys to filter values.</li> <li><code>column</code>: Key of the column being filtered.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_enter_row</code> <p>Callback triggered when the mouse enters a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_leave_row</code> <p>Callback triggered when the mouse leaves a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_position_change</code> <p>Callback triggered when the cursor position changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>name</code>: Key of the column where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>mode</code>: Interaction mode, either \"EDIT\" or \"SELECT\".</li> <li><code>cause</code>: Reason for the position change (e.g., \"key\", \"blur\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_subset_change</code> <p>Callback triggered when the subset of visible rows changes. Will be called with the following parameters:</p> <ul> <li><code>subset</code>: List of indices representing the new subset of rows.</li> </ul> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedText","title":"<code>AnnotatedText</code>","text":"<p>The <code>AnnotatedText</code> is a rich text viewer that supports span-level annotations, nested token highlights, and various user event callbacks.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedText--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback, use_state\nfrom pret.ui.metanno import AnnotatedText\nfrom pret.ui.joy import Button, Box\n\ntxt = (\n    \"Metanno brings annotation components to Pret\\n\"\n    \"to build tailored annotation tools.\"\n)\n\n# One span covering the word \u201cMetanno\u201d\nspans = create_store([{\n    \"id\": f\"span-0-7\",\n    \"begin\": 0,\n    \"end\": 7,\n    \"label\": \"OBJ\",\n    \"highlighted\": False,\n}])\n\ntxt_annotation_styles = create_store({\n    \"OBJ\": {\n        \"color\": \"red\",\n        \"shape\": \"underline\",\n    }\n})\n\n@component\ndef MyText():\n    tracked_spans = use_store_snapshot(spans)\n    tracked_styles = use_store_snapshot(txt_annotation_styles)\n\n    @use_event_callback\n    def handle_select(ranges, modkeys):\n        for sp in ranges:\n            spans.extend([\n                {\n                    \"id\": f\"span-{sp['begin']}-{sp['end']}\",\n                    \"begin\": sp[\"begin\"],\n                    \"end\": sp[\"end\"],\n                    \"label\": \"OBJ\",\n                }\n            ])\n\n    def on_mouse_enter_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = True\n\n    def on_mouse_leave_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = False\n\n    def on_span_style_change():\n        old_style = txt_annotation_styles[\"OBJ\"][\"shape\"]\n        new_style = \"box\" if old_style == \"underline\" else \"underline\"\n        txt_annotation_styles[\"OBJ\"][\"shape\"] = new_style\n\n    return Box(\n        Button(\"Change style\", on_click=on_span_style_change),\n        Button(\"Remove annotations\", on_click=lambda: spans.clear()),\n        AnnotatedText(\n            text=txt,\n            spans=tracked_spans,\n            annotation_styles=tracked_styles,\n            on_mouse_select=handle_select,\n            on_mouse_enter_span=on_mouse_enter_span,\n            on_mouse_leave_span=on_mouse_leave_span,\n            style={\"gridColumn\": \"1 / -1\"},\n        ),\n        sx={\"p\": 1, \"display\": \"grid\", \"gridTemplateColumns\": \"repeat(2, auto)\", \"gap\": 1},\n    )\n\nMyText()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedText--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>text</code> <p>Raw text content shown in the viewer.</p> <p> TYPE: <code>str</code> </p> <code>spans</code> <p>Span-level annotations over <code>text</code>.  Each span must include <code>begin</code> and <code>end</code> character offsets, with optional fields:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Category name displayed next to / above the span.</li> <li><code>style</code>: Key referencing <code>annotation_styles</code>.</li> <li><code>selected</code> (bool): styled as selected by the user.</li> <li><code>highlighted</code> (bool): styled as highlighted by the user.</li> </ul> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>annotation_styles</code> <p>Named style presets that control span background color, border, label placement, etc. Each style may define properties such as:</p> <ul> <li><code>color</code> (str): Color of the span. Will be overridden by <code>backgroundColor</code> and <code>borderColor</code>.</li> <li><code>shape</code> (\"underline\" | \"box\"): Visual style of the span.</li> <li><code>backgroundColor</code> (str): Background color of the span (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>borderColor</code> (str): Border color of the span (e.g. <code>\"#000000\"</code>).</li> <li><code>autoNestingLayout</code> (bool): Whether to automatically nest overlapping spans, rather than rendering them on top of each other.</li> </ul> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> <code>mouse_selection</code> <p>Current mouse drag selection expressed as character\u2010offset ranges. Passed to <code>on_mouse_select</code> when the action completes.</p> <p> TYPE: <code>List[Dict[str, int]]</code> </p> <code>style</code> <p>CSS style overrides for the outer element.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>actions</code> <p>Optional imperative helpers (<code>scroll_to_span</code> \u2026, <code>clear_current_mouse_selection</code>).</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>React reconciliation key.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click_span</code> <p>Called when the user clicks on a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_key_press</code> <p>Called when a key is pressed with focus inside the component.</p> <ul> <li><code>key</code> \u2013 Key name</li> <li><code>ranges</code> \u2013 Current selection ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[Dict[str, int]], List[str]], None]</code> </p> <code>on_mouse_enter_span</code> <p>Called when the mouse pointer enters a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the span entered</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_leave_span</code> <p>Called when the mouse pointer leaves a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the span left</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_select</code> <p>Triggered when the user finishes selecting text with the mouse.</p> <ul> <li><code>ranges</code> \u2013 Final list of selected ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[Dict[str, int]], List[str]], None]</code> </p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Improved visibility of highlighted spans and layout of boxes with mixed inset/outset nesting</li> <li>Improved autocompletion experience for table suggestion inputs</li> </ul>"},{"location":"changelog/#v100beta1","title":"v1.0.0.beta1","text":"<ul> <li>Complete refacto of the framework: the Python-JS synchronized app mechanisms have been moved to a new library: Pret !</li> <li>Text and Table components are now callable directly from python, along other components built around MUI Joy. This gives the user the ability to easily build simple apps, and iterate on the design step by step.</li> <li>Metanno now features new Image annotation component.</li> <li>The tests run in Python 3.7 - 3.10, using playwright in headless Firefox, Chrome and Webkit.</li> <li>Metanno now also has a nice interactive documentation !</li> </ul>"},{"location":"changelog/#metanno-v0","title":"Metanno v0","text":"<p>Metanno v0 is a JupyterLab extension for building custom annotation interfaces. It focuses on textual documents with structured entities and aims for modularity, customization, and interactivity. Core features include multi-line and nested span annotations, table-based relational annotations, multiple data types (hyperlinks, text, lists), and an immutable state that can be synchronized between the frontend and backend. The project compiles Python app classes to JavaScript using Transcrypt, enabling fast, browser-side execution while keeping Python code on the kernel side. To create an app, the user must modify one of the apps in recipes/*.py, and handle state management using a huge Redux-style reducer in <code>select_state</code>.</p> <p>Last items in the v0 changelog:</p> <ul> <li>Almost complete typescript conversion</li> <li>Added column filters</li> <li>Customizable undo/redo logic</li> <li>Editable span annotations from a table view</li> <li>Accessible return value of a Python call from front end (async calls)</li> </ul>"}]}