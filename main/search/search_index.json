{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#_1","title":"","text":"<p>Metanno is a Python library built on top of the Pret framework for building dynamic, customizable annotation interfaces.</p> <p>Who is it for? Research groups, clinical NLP and biomedical teams, data labeling squads, and anyone who wants custom and interactive annotation tools without wrestling with JavaScript.</p> <p>Metanno currently focuses on text and images with richly structured entities. Its goals are:</p> <ul> <li>Modularity: show your data from multiple synchronized angles. For example, highlight entities over text or images while editing the same rows in a table.</li> <li>Python\u2011first UI: write the entire app in Python; it renders to a fast React UI under the hood.</li> <li>Interactivity: handle annotations as plain Python objects at any time, so you can create, inspect, and transform them programmatically.</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#annotate-anything","title":"Annotate anything","text":"<p>In addition to the Pret ecosystem component suite, Metanno provides components for common annotation views:</p> <ul> <li>AnnotatedText: display text with highlighted, nestable spans</li> <li>AnnotatedImage: draw shapes (boxes, polygons, etc.) over images.</li> <li>Table: an editable, filterable spreadsheet\u2011style grid for inspecting and editing annotations.</li> </ul> <p>You can compose these views of the same underlying annotations to get a better grasp of the data you are annotating or inspecting.</p>"},{"location":"#run-it-your-way","title":"Run it your way","text":"<p>Use Metanno in two modes:</p> <ul> <li>Standalone app: run a server and use it in your browser.</li> <li>JupyterLab widgets: embed components directly in notebooks, with no extra ports or separate server process.</li> </ul> <p>Develop and test in a notebook. If you prefer, you can also run it as a standalone app.</p>"},{"location":"#easy-setup","title":"Easy setup","text":"<pre><code>pip install metanno\n</code></pre> <p>To use it with Jupyter, if you install the library in a custom environment (conda, venv, or other), you will likely need to tell Jupyter where to find the front-end files. You can do this by running the following command (only once):</p> <pre><code>pret update-jupyter-config --apply\n</code></pre> <p>Unlike other alternatives, Metanno requires no additional ports and no separate server process when used in JupyterLab. Write your app in Python and benefit from a fast React front end under the hood.</p>"},{"location":"#interactive-and-customizable-by-design","title":"Interactive and customizable by design","text":"<ul> <li>Inspect and edit application state directly from Python.</li> <li>Update the UI from Python; execute a notebook cell to see changes immediately.</li> <li>Register event handlers for clicks, hovers, keystrokes, and more.</li> </ul>"},{"location":"#why-another-annotation-software","title":"Why another annotation software?","text":"<p>Tool choice shapes both the annotation scheme and the workflow. In many out\u2011of\u2011the\u2011box tools, tasks like annotating implicit or document\u2011level entities, working across multiple documents at once, or coordinating multiple views can be difficult or unsupported. There are many available solutions (see Neves et al.). However,  most of these are either proprietary, poorly adapted to document or multi-document annotation, require a complex installation that is not compatible with existing strict remote computing environments, or are difficult to customize.</p> <p>Metanno takes a different approach: a modular, Python\u2011first framework that adapts to your schema and to your annotation process, instead of forcing you into fixed layers or rigid UIs.</p>"},{"location":"#demo","title":"Demo","text":"<p>See the demo apps, listed below.</p> <p> Quaero Explorer</p><p>Explore and edit the Quaero dataset.</p>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Check out the tutorials to get started with Metanno !</p> <p> Set up a new project</p><p>Learn how to install Metanno in a new project or add it to an existing one.</p><p> Run the Data Explorer demo</p><p>Run the Quaero Explorer demo app and discover its features: persisting annotations, collaborating, and more.</p><p> Customize the Data Explorer</p><p>Learn how to pre-annotate entities using EDS-NLP and annotate higher-level structures in the Data Explorer.</p>"},{"location":"#small-example","title":"Small example","text":"<p>Below is a small example that lets you annotate text spans and view them in a synchronized table. Select spans to add them; hold Shift (also labeled Maj on some keyboards) while selecting to delete overlapping spans.</p> Show code <pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import AnnotatedText\n\nstate = create_store(\n    [\n        {\"text\": \"soir\", \"begin\": 3, \"end\": 7, \"id\": \"s-3-7\", \"label\": \"ENT\"},\n        {\"text\": \"Charlie\", \"begin\": 59, \"end\": 66, \"id\": \"s-59-66\", \"label\": \"ENT\"},\n    ]\n)\n\ntext = (\n    \"Le soir, apr\u00e8s avoir mang\u00e9 sa soupe aux choux noy\u00e9e \"\n    \"d\u2019eau, Charlie allait toujours dans la chambre de ses \"\n    \"quatre grands-parents pour \u00e9couter leurs histoires, \"\n    \"et pour leur souhaiter bonne nuit.\\n\"\n    \"Chacun d\u2019eux avait plus de quatre-vingt-dix ans. Ils \"\n    \"\u00e9taient frip\u00e9s comme des pruneaux secs, ossus comme \"\n    \"des squelettes et, toute la journ\u00e9e, jusqu\u2019\u00e0 l\u2019apparition \"\n    \"de Charlie, ils se pelotonnaient dans leur lit, deux de \"\n    \"chaque c\u00f4t\u00e9, coiff\u00e9s de bonnets de nuit qui leur tenaient \"\n    \"chaud, passant le temps \u00e0 ne rien faire.\"\n)\n\n\n@component\ndef App():\n    view_state = use_store_snapshot(state)\n\n    @use_event_callback\n    def on_select(spans, mod_keys):\n        if \"Shift\" in mod_keys:\n            # Delete overlapped spans if the user holds Shift\n            state[:] = [\n                x\n                for x in state\n                if any(\n                    (s[\"begin\"] &gt;= x[\"end\"] or s[\"end\"] &lt;= x[\"begin\"]) for s in spans\n                )\n            ]\n        else:\n            state.extend(\n                [\n                    {\n                        **s,\n                        \"id\": f\"s-{s['begin']}-{s['end']}\",\n                        \"text\": text[s[\"begin\"] : s[\"end\"]],\n                        \"label\": \"ENT\",\n                    }\n                    for s in spans\n                ]\n            )\n\n    return AnnotatedText(\n        text=text,\n        spans=view_state,\n        annotation_styles={\"ENT\": {\"color\": \"lightblue\"}},\n        on_mouse_select=on_select,\n    )\n\n\nApp()\n</code></pre> <p>The annotations are reflected in the table below. Both views stay in sync because they share the same state (<code>state</code>).</p> Show code <pre><code># \u2191 Complete the code above with the following snippet \u2191\nfrom pret import component, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import Table\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"begin\", \"kind\": \"text\", \"name\": \"begin\", \"filterable\": True},\n    {\"key\": \"end\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True},\n    {\"key\": \"label\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True,\n        \"editable\": True, \"choices\": [\"ENT\", \"OTHER\"]},\n]\n\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        view_state[row_idx][col] = new_value\n\n    for x in state:\n        x.setdefault(\"label\", \"ENT\")  # Ensure all rows have a label\n\n    view_state = use_store_snapshot(state)\n    return Table(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\n\nMyTable()\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#as-a-user","title":"As a user","text":"<p>A simple pip installation should be enough to install Metanno both as a standalone web app framework and as a JupyterLab extension:</p> <pre><code>pip install metanno\n</code></pre> <p>To use it with Jupyter, if you install the library in a custom environment (conda, venv, or other), you will likely need to tell Jupyter where to find the front-end files. You can do this by running the following command (only once):</p> <pre><code>pret update-jupyter-config --apply\n</code></pre>"},{"location":"installation/#as-a-contributor","title":"As a contributor","text":"<p>If you want to contribute to Metanno, you should have a programming environment:</p> <ul> <li>Python 3.7 or later, with pip and hatch installed</li> <li>Node.js 20 or later (you can use nvm to easily install and manage Node.js versions)</li> <li>JupyterLab 3 (the built extension will be compatible with JupyterLab 4)</li> <li>Various web browsers for testing (e.g., Chrome, Firefox, Safari)</li> <li>A Git client to clone the repository and manage your changes</li> </ul> <pre><code>git clone https://github.com/percevalw/metanno.git\ncd metanno\n</code></pre> <p>Then, create a new branch for your changes:</p> <pre><code>git checkout -b my-feature-branch\n</code></pre> <p>Create (optional) virtual env and install all development deps. Install the package in editable mode with development dependencies:</p> <pre><code>yarn install\npip install -e . --group dev  #(1)!\nyarn playwright install --with-deps # browsers for UI tests\n</code></pre> <ol> <li>or <code>uv pip install -e . --group dev</code> with uv</li> </ol>"},{"location":"installation/#running-the-ui-tests","title":"Running the UI tests","text":"<p>Metanno uses playwright to test the JupyterLab extension (which should cover most of the app features). You can run the tests to ensure everything is working correctly.</p> <pre><code>sh tests/jupyter/run.sh #(1)!\n</code></pre> <ol> <li>or <code>uv run sh tests/jupyter/run.sh</code> with uv</li> </ol>"},{"location":"installation/#building-the-documentation","title":"Building the documentation","text":"<p>The documentation is built with MkDocs and MkDocs Material theme, along with quite a few customizations. To build the documentation, you can use the following command:</p> <pre><code>pip install -e . --group docs  #(1)!\nmkdocs serve  #(2)!\n</code></pre> <ol> <li>or <code>uv pip install -e . --group docs</code> with uv</li> <li>or <code>uv run mkdocs serve</code> with uv</li> </ol> <ol></ol>"},{"location":"components/","title":"Building Blocks of Metanno","text":"<p>This page provides an overview of the base components available in Metanno.</p> Component Description AnnotatedText View and interact with a text with optional annotations. AnnotatedImage View and interact with an image with optional annotations. Table View and interact with a table"},{"location":"components/annotated-image/","title":"AnnotatedImage","text":""},{"location":"components/annotated-image/#pret.ui.metanno.AnnotatedImage","title":"AnnotatedImage","text":"<p>An interactive image viewer that supports drawing, selecting, and styling geometric shapes (polygons, rectangles, points...) as annotations.</p> <p>Under the hood, we use Konva to render the image and its annotations.</p>"},{"location":"components/annotated-image/#pret.ui.metanno.AnnotatedImage--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import AnnotatedImage\nimport time\n\n# Reactive store holding the annotation list\nimg_state = create_store([\n    {\n        \"id\": \"1\",\n        \"type\": \"polygon\",\n        \"points\": [10, 10, 50, 20],\n        \"label\": \"OBJ\",\n        \"style\": \"primary\",\n    }\n])\n\n# Style preset referenced from the annotation above\nimg_annotation_styles = {\n    \"primary\": {\n        \"strokeColor\": \"red\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"rgba(255,0,0,0.5)\",\n        \"labelPosition\": \"center\",\n        \"align\": \"center\",\n        \"verticalAlign\": \"top\",\n    },\n    \"secondary\": {\n        \"strokeColor\": \"blue\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"#0000ff80\",\n        \"textColor\": \"white\",\n    }\n}\n\n@component\ndef MyImage():\n    tracked_state = use_store_snapshot(img_state)\n\n    @use_event_callback\n    def on_mouse_select(modkeys, shapes):\n        # Toggle 'mouseSelected' flag\n        for shp in shapes:\n            img_state.append({\n                \"id\": str(time.time()),\n                \"points\": shp[\"points\"],\n                \"label\": \"OBJ\",\n                \"style\": \"primary\",\n            })\n\n    @use_event_callback\n    def on_click(shape_idx, modkeys):\n        if shape_idx is None:\n            img_state.clear()\n        else:\n            old_style = img_state[shape_idx].get(\"style\", \"primary\")\n            new_style = \"secondary\" if old_style == \"primary\" else \"primary\"\n            img_state[shape_idx][\"style\"] = new_style\n\n    return AnnotatedImage(\n        image=\"https://picsum.photos/400/300\",\n        annotations=tracked_state,\n        annotation_styles=img_annotation_styles,\n        on_mouse_select=on_mouse_select,\n        on_click=on_click,\n    )\n\nMyImage()\n</code></pre>"},{"location":"components/annotated-image/#pret.ui.metanno.AnnotatedImage--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>annotations</code> <p>List of annotation objects drawn on top of the image. Each annotation must contain the geometric <code>type</code> and <code>points</code> fields (defining the shape) plus optional metadata such as:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Human-readable text shown next to the shape.</li> <li><code>style</code>: Key that looks up visual properties in <code>annotation_styles</code>.</li> <li><code>selected</code> / <code>highlighted</code> / <code>mouseSelected</code>: Booleans used by the   component when rendering interaction state.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>annotation_styles</code> <p>Named style presets referenced by the <code>style</code> field of an annotation.  Each preset may define properties such as stroke color, fill color, opacity, font size, and label alignment, using the following properties:</p> <ul> <li><code>strokeColor</code> (str): Color of the shape's stroke (e.g. <code>\"#ff0000\"</code>).</li> <li><code>strokeWidth</code> (int): Width of the shape's stroke in pixels.</li> <li><code>fillColor</code> (str): Background color of the shape (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>opacity</code> (float): Opacity of the shape's fill (0.0 to 1.0).</li> <li><code>shape</code> (str): Shape type, e.g. <code>\"polygon\"</code>, <code>\"rectangle\"</code>, <code>\"circle\"</code>, etc.</li> <li><code>fontSize</code> (int): Font size for the label text.</li> <li><code>align</code> (\"left\" | \"center\" | \"right\"): Horizontal alignment of the label text.</li> <li><code>verticalAlign</code> (\"top\" | \"middle\" | \"bottom\"): Vertical alignment of the label text.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>image</code> <p>Source URL or base-64 data URI of the image to annotate.</p> <p> TYPE: <code>str</code> </p> <code>mouse_selection</code> <p>Temporary shapes being drawn by the user while the mouse button is held down.  Supplied back to <code>on_mouse_select</code> when the gesture ends.</p> <p> TYPE: <code>Any</code> </p> <code>style</code> <p>Inline CSS-compatible style overrides for the root element of the component.</p> <p> TYPE: <code>Any</code> </p> <code>actions</code> <p>Optional imperative handles (e.g. <code>actions[\"scroll_to_shape\"](idx)</code>) that the parent may call.  Reserved for future expansion.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>React key for stable reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click</code> <p>Invoked when the user clicks on an existing shape.</p> <ul> <li><code>shape_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 List of pressed modifier keys (e.g. <code>[\"Shift\"]</code>)</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_key_press</code> <p>Invoked when the component has focus and the user presses a key.</p> <ul> <li><code>key</code> \u2013 The key name (<code>\"Escape\"</code>, <code>\"Delete\"</code> \u2026)</li> <li><code>modkeys</code> \u2013 Concurrently pressed modifier keys</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_mouse_enter_shape</code> <p>Hover callbacks fired when the mouse pointer enters or leaves a shape.</p> <p> TYPE: <code>Any</code> </p> <code>on_mouse_select</code> <p>Fired after the user completes a drag selection.</p> <ul> <li><code>modkeys</code> \u2013 Modifier keys pressed during selection</li> <li><code>shapes</code> \u2013 All shapes inside the lasso / rectangle</li> </ul> <p> TYPE: <code>Any</code> </p>"},{"location":"components/annotated-text/","title":"AnnotatedText","text":""},{"location":"components/annotated-text/#pret.ui.metanno.AnnotatedText","title":"AnnotatedText","text":"<p>The <code>AnnotatedText</code> is a rich text viewer that supports span-level annotations, nested token highlights, and various user event callbacks.</p>"},{"location":"components/annotated-text/#pret.ui.metanno.AnnotatedText--examples","title":"Examples","text":"<pre><code>from pret import (\n    component,\n    create_store,\n    use_store_snapshot,\n    use_event_callback,\n    use_state,\n)\nfrom pret.ui.metanno import AnnotatedText\nfrom pret.ui.joy import Button, Box\n\ntxt = (\n    \"Metanno brings annotation components to Pret\\n\"\n    \"to build tailored annotation tools.\"\n)\n\n# One span covering the word \u201cMetanno\u201d\nspans = create_store(\n    [\n        {\n            \"id\": f\"span-0-7\",\n            \"begin\": 0,\n            \"end\": 7,\n            \"label\": \"OBJ\",\n            \"highlighted\": False,\n        }\n    ]\n)\n\ntxt_annotation_styles = create_store(\n    {\n        \"OBJ\": {\n            \"color\": \"red\",\n            \"shape\": \"underline\",\n        }\n    }\n)\n\n\n@component\ndef MyText():\n    tracked_spans = use_store_snapshot(spans)\n    tracked_styles = use_store_snapshot(txt_annotation_styles)\n\n    @use_event_callback\n    def handle_select(ranges, modkeys):\n        for sp in ranges:\n            spans.extend(\n                [\n                    {\n                        \"id\": f\"span-{sp['begin']}-{sp['end']}\",\n                        \"begin\": sp[\"begin\"],\n                        \"end\": sp[\"end\"],\n                        \"label\": \"OBJ\",\n                    }\n                ]\n            )\n\n    def on_mouse_enter_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = True\n\n    def on_mouse_leave_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = False\n\n    def on_span_style_change():\n        old_style = txt_annotation_styles[\"OBJ\"][\"shape\"]\n        new_style = \"box\" if old_style == \"underline\" else \"underline\"\n        txt_annotation_styles[\"OBJ\"][\"shape\"] = new_style\n\n    return Box(\n        Button(\"Change style\", on_click=on_span_style_change),\n        Button(\"Remove annotations\", on_click=lambda: spans.clear()),\n        AnnotatedText(\n            text=txt,\n            spans=tracked_spans,\n            annotation_styles=tracked_styles,\n            on_mouse_select=handle_select,\n            on_mouse_enter_span=on_mouse_enter_span,\n            on_mouse_leave_span=on_mouse_leave_span,\n            style={\"gridColumn\": \"1 / -1\"},\n        ),\n        sx={\n            \"p\": 1,\n            \"display\": \"grid\",\n            \"gridTemplateColumns\": \"repeat(2, auto)\",\n            \"gap\": 1,\n        },\n    )\n\n\nMyText()\n</code></pre>"},{"location":"components/annotated-text/#pret.ui.metanno.AnnotatedText--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>text</code> <p>Raw text content shown in the viewer.</p> <p> TYPE: <code>str</code> </p> <code>spans</code> <p>Span-level annotations over <code>text</code>.  Each span must include <code>begin</code> and <code>end</code> character offsets, with optional fields:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Category name displayed next to / above the span.</li> <li><code>style</code>: Key referencing <code>annotation_styles</code>.</li> <li><code>selected</code> (bool): styled as selected by the user.</li> <li><code>highlighted</code> (bool): styled as highlighted by the user.</li> </ul> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>annotation_styles</code> <p>Named style presets that control span background color, border, label placement, etc. Each style may define properties such as:</p> <ul> <li><code>color</code> (str): Color of the span. Will be overridden by <code>backgroundColor</code> and <code>borderColor</code>.</li> <li><code>shape</code> (\"underline\" | \"box\"): Visual style of the span.</li> <li><code>backgroundColor</code> (str): Background color of the span (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>borderColor</code> (str): Border color of the span (e.g. <code>\"#000000\"</code>).</li> <li><code>autoNestingLayout</code> (bool): Whether to automatically nest overlapping spans, rather than rendering them on top of each other.</li> </ul> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> <code>mouse_selection</code> <p>Current mouse drag selection expressed as character\u2010offset ranges. Passed to <code>on_mouse_select</code> when the action completes.</p> <p> TYPE: <code>List[Dict[str, int]]</code> </p> <code>style</code> <p>CSS style overrides for the outer element.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>actions</code> <p>Optional imperative helpers (<code>scroll_to_span</code> \u2026, <code>clear_current_mouse_selection</code>).</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>React reconciliation key.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click_span</code> <p>Called when the user clicks on a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_key_press</code> <p>Called when a key is pressed with focus inside the component.</p> <ul> <li><code>key</code> \u2013 Key name</li> <li><code>ranges</code> \u2013 Current selection ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[Dict[str, int]], List[str]], None]</code> </p> <code>on_mouse_enter_span</code> <p>Called when the mouse pointer enters a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the span entered</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_leave_span</code> <p>Called when the mouse pointer leaves a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the span left</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_select</code> <p>Triggered when the user finishes selecting text with the mouse.</p> <ul> <li><code>ranges</code> \u2013 Final list of selected ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[Dict[str, int]], List[str]], None]</code> </p>"},{"location":"components/table/","title":"Table","text":""},{"location":"components/table/#pret.ui.metanno.Table","title":"Table","text":"<p>A component for displaying a table with various features such as filtering, highlighting rows, and handling cell changes.</p>"},{"location":"components/table/#pret.ui.metanno.Table--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import Table\n\ntable_state = create_store([\n    {\"id\": \"1\", \"date\": \"2023-01-01\", \"text\": \"Sample text 1\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"2\", \"date\": \"2023-01-03\", \"text\": \"Sample text 2\", \"type\": \"OTHER\", \"labels\": [\"ready\", \"danger\"]},\n    {\"id\": \"3\", \"date\": \"2023-01-05\", \"text\": \"Sample text 3\", \"type\": \"ENT\", \"labels\": [\"blue\"]},\n    {\"id\": \"4\", \"date\": \"2023-01-07\", \"text\": \"Sample text 4\", \"type\": \"OTHER\", \"labels\": [\"bad\"]},\n    {\"id\": \"5\", \"date\": \"2023-01-09\", \"text\": \"Sample text 5\", \"type\": \"ENT\", \"labels\": []},\n    {\"id\": \"6\", \"date\": \"2023-01-11\", \"text\": \"Sample text 6\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"7\", \"date\": \"2023-01-13\", \"text\": \"Sample text 7\", \"type\": \"FOO\", \"labels\": [\"ready\"]},\n    {\"id\": \"8\", \"date\": \"2023-01-15\", \"text\": \"Sample text 8\", \"type\": \"FOO2\", \"labels\": [\"danger\"]},\n    {\"id\": \"9\", \"date\": \"2023-01-17\", \"text\": \"Sample text 9\", \"type\": \"FOO3\", \"labels\": [\"blue\"]},\n    {\"id\": \"10\", \"date\": \"2023-01-19\", \"text\": \"Sample text 10\", \"type\": \"ENT\", \"labels\": [\"bad\"]},\n    {\"id\": \"11\", \"date\": \"2023-01-21\", \"text\": \"Sample text 11\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"12\", \"date\": \"2023-01-23\", \"text\": \"Sample text 12\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"13\", \"date\": \"2023-01-25\", \"text\": \"Sample text 13\", \"type\": \"OTHER\", \"labels\": [\"danger\"]},\n    {\"id\": \"14\", \"date\": \"2023-01-27\", \"text\": \"Sample text 14\", \"type\": \"FOO2\", \"labels\": [\"blue\"]},\n    {\"id\": \"15\", \"date\": \"2023-01-29\", \"text\": \"Sample text 15\", \"type\": \"FOO3\", \"labels\": [\"bad\"]},\n])\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"date\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True, \"editable\": True},\n    {\"key\": \"type\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\", \"STUFF\", \"FOO\", \"FOO2\", \"FOO3\"]},\n    {\"key\": \"labels\", \"kind\": \"multi-text\", \"name\": \"labels\", \"filterable\": True, \"editable\": True, \"choices\": [\"ready\", \"danger\", \"blue\", \"bad\", \"custom\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        table_state[row_idx][col] = new_value\n\n    view_state = use_store_snapshot(table_state)\n    return Table(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"components/table/#pret.ui.metanno.Table--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>columns</code> <p>The columns to display in the table:</p> <ul> <li><code>key</code>: Unique identifier for the column.</li> <li><code>name</code>: Display name of the column.</li> <li><code>kind</code>: Type of data in the column (e.g., \"text\", \"hyperlink\", \"multi-text\", \"boolean\", ...).</li> <li><code>editable</code>: Whether the column is editable.</li> <li><code>filterable</code>: Whether the column can be filtered.</li> <li><code>choices</code>: Optional list of choices for the column (if applicable).</li> </ul> <p> TYPE: <code>ColumnData</code> </p> <code>filters</code> <p>The current filters applied to the table, mapping column keys to filter values.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>highlighted_rows</code> <p>List of row indices that should be highlighted.</p> <p> TYPE: <code>List[int]</code> </p> <code>row_key</code> <p>The key used to uniquely identify each row in the table.</p> <p> TYPE: <code>str</code> </p> <code>rows</code> <p>The data for each row in the table, where each row is a dictionary mapping column keys to their values.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>actions</code> <p>Actions that can be performed on the table, such as scrolling.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>auto_filter</code> <p>Whether to automatically apply filters as the user types.</p> <p> TYPE: <code>bool</code> </p> <code>input_value</code> <p>The current input value to show in the input field when the user is editing a cell. If undefined, this is automatically handled by the component.</p> <p> TYPE: <code>Union[str, Hyperlink]</code> </p> <code>suggestions</code> <p>List of suggestions to show when the user is typing in the input field.</p> <p> TYPE: <code>List[Any]</code> </p> <code>position</code> <p>The current position of the cursor in the table, including:</p> <ul> <li>row_idx: Index of the row where the cursor is located.</li> <li>col: Key of the column where the cursor is located.</li> <li>mode: Mode of interaction, either \"EDIT\" or \"SELECT\".</li> </ul> <p> TYPE: <code>Position</code> </p> <code>style</code> <p>Custom styles for the table component.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>A unique key for the component instance, used for React's reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_input_change</code> <p>Callback triggered when the input value changes in a cell. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value entered by the user.</li> <li><code>cause</code>: Reason for the change (e.g., \"blur\", \"enter\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_scroll_bottom</code> <p>Callback triggered when the user scrolls to the bottom of the table. Will be called with the following parameters:</p> <ul> <li><code>event</code>: Scroll event or a dictionary indicating if the user is at the bottom.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_cell_change</code> <p>Callback triggered when a cell's value changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value of the cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_click_cell_content</code> <p>Callback triggered when the content of a cell is clicked (like a hyperlink). Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row containing the clicked cell.</li> <li><code>name</code>: Key of the column containing the clicked cell.</li> <li><code>value</code>: Optional value of the clicked cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_filters_change</code> <p>Callback triggered when filters are updated. Will be called with the following parameters:</p> <ul> <li><code>values</code>: Dictionary mapping column keys to filter values.</li> <li><code>column</code>: Key of the column being filtered.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_enter_row</code> <p>Callback triggered when the mouse enters a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_leave_row</code> <p>Callback triggered when the mouse leaves a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_position_change</code> <p>Callback triggered when the cursor position changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>name</code>: Key of the column where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>mode</code>: Interaction mode, either \"EDIT\" or \"SELECT\".</li> <li><code>cause</code>: Reason for the position change (e.g., \"key\", \"blur\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_subset_change</code> <p>Callback triggered when the subset of visible rows changes. Will be called with the following parameters:</p> <ul> <li><code>subset</code>: List of indices representing the new subset of rows.</li> </ul> <p> TYPE: <code>Callable</code> </p>"},{"location":"demos/","title":"Demos","text":"<p>Here are some examples of applications you can build with Metanno.</p> <p> Quaero Explorer</p><p>Explore and edit the Quaero dataset.</p>"},{"location":"demos/quaero-explorer/","title":"Quaero explorer","text":"<pre><code>from examples.quaero import app\n\n\napp(deduplicate=True)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Here is a list of tutorials to help you learn how to use Metanno.</p> <p>For a deeper understanding of the framework, check out the Pret tutorials.</p> <p> Set up a new project</p><p>Learn how to install Metanno in a new project or add it to an existing one.</p><p> Run the Data Explorer demo</p><p>Run the Quaero Explorer demo app and discover its features: persisting annotations, collaborating, and more.</p><p> Customize the Data Explorer</p><p>Learn how to pre-annotate entities using EDS-NLP and annotate higher-level structures in the Data Explorer.</p>"},{"location":"tutorials/customize-explorer/","title":"Customize the data explorer app","text":"<p>In this tutorial, we are going to expose different ways to customize the Data Explorer app (demoed with the Quaero dataset in the previous tutorial:</p> <ul> <li>Add new fields to the data model and display them in the UI.</li> <li>Pre-annotate entities using EDS-NLP.</li> <li>Annotate higher-level structures such as patients the notes are attached to</li> </ul>"},{"location":"tutorials/customize-explorer/#prerequisites","title":"Prerequisites","text":"<p>Reuse the same environment you prepared in the Run Quaero Explorer tutorial and run the app in a notebook or as a standalone app.</p>"},{"location":"tutorials/customize-explorer/#adding-new-fields","title":"Adding new fields","text":"<p>You control which attributes appear in the UI by editing the data you import and by listing those attributes in the table views. Check out the Table component documentation for more details about the types of attributes you can add.</p>"},{"location":"tutorials/customize-explorer/#load-the-data","title":"Load the data","text":"<p>For example, add a <code>note_type</code> to notes and a <code>negation</code> field to entities.</p> <pre><code>notes = [\n    {\n        \"note_id\": doc._.note_id,\n        \"note_text\": doc.text,\n        # This is an example. Make sure that your data actually has this attribute\n+       \"note_type\": doc._.note_type, #(1)!\n   }\n    for doc in data\n]\n</code></pre> <pre><code>entities = [\n    {\n        \"id\": f\"#-{doc._.note_id}-{e.start_char}-{e.end_char}-{e.label_}\",\n        \"note_id\": doc._.note_id,\n        \"text\": str(e),\n        \"begin\": e.start_char,\n        \"end\": e.end_char,\n        \"label\": e.label_,\n        \"concept\": e._.cui,\n        # This is an example. Make sure that your data actually has this attribute\n+       \"negation\": e._.negation, #(1)!\n   }\n    for doc in data\n    for e in sorted(doc.spans[\"entities\"])\n]\n</code></pre>"},{"location":"tutorials/customize-explorer/#show-these-fields","title":"Show these fields","text":"<p>Update the table/text renderers in the Build the views section to include the new attributes. Metanno will automatically detect that the negation attribute is boolean and will display it as a checkbox.</p> <pre><code>- first_columns=[\"note_id\", \"seen\", \"note_text\"],\n+ first_columns=[\"note_id\", \"seen\", \"note_type\", \"note_text\"],\n...\n- editable_columns=[\"seen\"],\n+ editable_columns=[\"seen\", \"review_status\"],\n</code></pre> <pre><code>- first_columns=[\"id\", \"note_id\", \"text\", \"label\", \"concept\", \"begin\", \"end\"],\n+ first_columns=[\"id\", \"note_id\", \"text\", \"label\", \"concept\", \"begin\", \"end\", \"negation\"],\n...\n- editable_columns=[\"label\", \"concept\"],\n+ editable_columns=[\"label\", \"concept\", \"source\"],\n</code></pre> <p>Dropdown input</p> <p>Add any new columns to <code>categorical_columns</code> if they should show a dropdown filter like the <code>concept</code> column.</p>"},{"location":"tutorials/customize-explorer/#pre-annotation","title":"Pre-annotation","text":"<p>TBD</p>"},{"location":"tutorials/customize-explorer/#annotate-higher-level-structures","title":"Annotate higher-level structures","text":"<p>TBD</p>"},{"location":"tutorials/new-project/","title":"Set up a new project","text":""},{"location":"tutorials/new-project/#set-up-a-new-project","title":"Set up a new project","text":"<p>Learn how to install Metanno in a brand\u2011new project or add it to an existing one.</p>"},{"location":"tutorials/new-project/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python &gt;= 3.7</li> <li>A clean environment (Conda/Mamba recommended).   On JupyterHub: use a conda/mamba environment (or micromamba). Avoid local environments like <code>venv</code> there to ensure JupyterLab picks up the front\u2011end code properly.</li> </ul> <p>Two ways to run Metanno</p> <ul> <li>Inside JupyterLab (great for notebooks and quick prototyping)</li> <li>Standalone app (run a local web server)</li> </ul>"},{"location":"tutorials/new-project/#create-or-reuse-a-project","title":"Create (or reuse) a project","text":"<p>You can manage your project dependencies with a pyproject.toml or a requirements.txt.</p> pyproject.tomlrequirements.txt <p>Below is a minimal example that starts from a dummy project and adds a dependency group for metanno:</p> <pre><code>[project]\nname = \"my-app\"\nversion = \"0.1.0\"\nrequires-python = \"&gt;=3.7\"\ndependencies = [\n\"edsnlp&gt;=0.17\",  # example base dependency\n]\n\n[dependency-groups]\nmetanno = [\n\"metanno\",   # the annotation framework\n# add other dependencies as your annotation app grows\n]\n</code></pre> <p>Create and activate an environment, then (re-)install your project with the <code>metanno</code> group:</p> <pre><code>mamba create -n metanno python=3.11 -y\nmamba activate metanno\npip install . --group metanno\n</code></pre> <p>If you are adding to an existing project, just merge the <code>[dependency-groups]</code> section above and reinstall with <code>pip install . --group metanno</code></p> <p>If you don\u2019t want a pyproject.toml, create a requirements.txt:</p> <pre><code>metanno\nedsnlp&gt;=0.13  # example additional dependency, not required at the moment\n</code></pre> <p>Then install in your environment:</p> <pre><code>mamba create -n metanno python=3.11 -y\nmamba activate metanno\npip install -r requirements.txt\n</code></pre>"},{"location":"tutorials/new-project/#use-in-jupyterlab","title":"Use in JupyterLab","text":"<ol> <li>If JupyterLab was already open, refresh the browser tab after installation.</li> <li>Create a new notebook</li> <li>Make sure you\u2019re using the Conda/Mamba environment where you installed Metanno.    To check, run the following in a new cell:    <pre><code>import sys\n\nprint(sys.executable)\n</code></pre>    It should show the path to the environment where you installed the app.    If it does, you can skip to the next step.    Otherwise, select the correct environment from the dropdown menu in the top\u2011right of the notebook.    If your environment does not appear, it means you have not yet \"linked\" it to JupyterLab.    Run the following command in the terminal:    <pre><code>mamba activate metanno\npip install ipykernel\npython -m ipykernel install --user --name metanno\n</code></pre></li> <li>Then run the following dummy app in a new cell:</li> </ol> <pre><code>from pret import component\nfrom pret.ui.joy import Button\n\n\n@component\ndef SanityCheckApp():\n    return Button(\"Metanno is installed \u2705\", sx={\"m\": 1})\n\n\nSanityCheckApp()\n</code></pre> <p>If you see a clickable button appear below the cell, your JupyterLab setup is good to go.</p>"},{"location":"tutorials/new-project/#use-as-a-standalone-app","title":"Use as a standalone app","text":"<p>Create a file <code>app.py</code> with the same minimal app and run it locally. Ensure that you are in an environment where you can open ports (for instance port 5000 as in the example below), or contact your sysadmin.</p> <pre><code>from pret import run, component\nfrom pret.ui.joy import Button\n\n\n@component\ndef SanityCheckApp():\n    return Button(\"Metanno is installed \u2705\", sx={\"m\": 1})\n\n\nif __name__ == \"__main__\":\n    run(SanityCheckApp(), port=5000)\n</code></pre> <p>Run the app:</p> <pre><code>python app.py\n</code></pre> <p>Your terminal will print a local URL. Open it in your browser and you should see the button displayed.</p>"},{"location":"tutorials/run-quaero-explorer/","title":"Run the Quaero Explorer","text":"<p>Run the Quaero Explorer demo app and discover Metanno\u2019s collaborative workflow: real\u2011time syncing, multi\u2011panel editing, and simple persistence.</p>"},{"location":"tutorials/run-quaero-explorer/#prerequisites","title":"Prerequisites","text":"<p>Reuse the same environment you prepared in the New project tutorial. You should already have a working Python environment with Pret, Metanno, and EDS\u2011NLP installed.</p> <p>The script downloads the Quaero FrenchMed dataset on first run, so an Internet access is required.</p> <p>Create a new file named <code>quaero.py</code> in your project and copy the contents from the official example https://github.com/percevalw/metanno/blob/main/examples/quaero.py.</p>"},{"location":"tutorials/run-quaero-explorer/#run-the-app","title":"Run the app","text":"<pre><code>from collections import Counter\nfrom pathlib import Path\n\nimport edsnlp\n\nfrom metanno.recipes.explorer import DatasetApp\nfrom pret import component, use_store_snapshot\nfrom pret.ui.markdown import Markdown\nfrom pret.ui.react import div\nfrom pret.ui.simple_dock import Layout, Panel\n</code></pre> <p>From a terminal. The server will start at http://localhost:5000.</p> <pre><code>python quaero.py --port 5000\n</code></pre> <p>Or in JupyterLab, run the following cell:</p> <pre><code>from quaero import app\n\napp()\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#code-breakdown","title":"Code breakdown","text":"<p>Below, we break down the script.</p>"},{"location":"tutorials/run-quaero-explorer/#1-load-the-data","title":"1) Load the data","text":"<p>We first fetch and extracts the dataset if it isn\u2019t already present, and read the BRAT standoff annotations using EDS-NLP. We then build two Python lists: <code>notes</code> and <code>entities</code> with the fields we\u2019ll display and edit.</p> <pre><code>download_quaero()\n\ndata = edsnlp.data.read_standoff(\n    DOWNLOAD_DIR / \"QUAERO_FrenchMed/corpus\",\n    span_setter=\"entities\",\n    notes_as_span_attribute=\"cui\",\n)\nnotes = [\n    {\n        \"note_id\": doc._.note_id,\n        \"note_text\": doc.text,\n        \"seen\": False,\n    }\n    for doc in data\n]\nentities = [\n    {\n        \"id\": f\"#-{doc._.note_id}-{e.start_char}-{e.end_char}-{e.label_}\",\n        \"note_id\": doc._.note_id,\n        \"text\": str(e),\n        \"begin\": e.start_char,\n        \"end\": e.end_char,\n        \"label\": e.label_,\n        \"concept\": e._.cui,\n    }\n    for doc in data\n    for e in sorted(doc.spans[\"entities\"])\n]\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#2-check-unique-entity-ids","title":"2) Check unique entity IDs","text":"<p>The Table component requires unique IDs for each row. We check if the entity IDs are unique and raise an error if not, or deduplicate them automatically.</p> <pre><code>if deduplicate:\n    entities = list({v[\"id\"]: v for v in entities}.values())\nelse:\n    counter = Counter(e[\"id\"] for e in entities)\n    if any(count &gt; 1 for count in counter.values()):\n        raise ValueError(\n            \"Duplicate IDs found in the dataset: \"\n            + \", \".join(f\"{id_} (x{n})\" for id_, n in counter.items() if n &gt; 1)\n        )\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#3-configure-labels","title":"3) Configure labels","text":"<p>We compute a stable list of labels, assign a color for each, and auto\u2011pick a one\u2011letter keyboard shortcut per label.</p> <pre><code>all_labels = list(dict.fromkeys(e[\"label\"] for e in entities))\nshortcuts = set()\nlabels_config = {}\nfor i, label in enumerate(all_labels):\n    labels_config[label] = {}\n    if i &lt; len(PALETTE):\n        labels_config[label][\"color\"] = PALETTE[i]\n    letter = next(c for c in label.lower() if c not in shortcuts)\n    shortcuts.add(letter)\n    labels_config[label][\"shortcut\"] = letter\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#4-instantiate-the-manager","title":"4) Instantiate the manager","text":"<p>We create a DatasetApp (a ready\u2011to\u2011customize recipe, you may also see it referred to as a \"Dataset Explorer\" in the docs). Under the hood, it composes Metanno components such as Table, AnnotatedText, buttons with a bit of app logic.</p> <pre><code>app = DatasetApp(\n    {\n        \"notes\": notes,\n        \"entities\": entities,\n    },\n    sync=save_path,\n)\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#5-build-the-views","title":"5) Build the views","text":"<p>We define the views that will be rendered in the app. Each view is a component that displays a specific part of the data.</p> <pre><code>notes_view = app.render_table(\n    view_name=\"notes\",\n    store_key=\"notes\",\n    pkey_column=\"note_id\",\n    id_columns=[\"note_id\"],\n    first_columns=[\"note_id\", \"seen\", \"note_text\"],\n    editable_columns=[],\n    categorical_columns=[],\n    hidden_columns=[],\n    style={\"--min-notebook-height\": \"300px\"},\n)\nentities_view = app.render_table(\n    view_name=\"entities\",\n    store_key=\"entities\",\n    pkey_column=\"id\",\n    first_columns=[\"id\", \"note_id\", \"text\", \"label\", \"concept\", \"begin\", \"end\"],\n    id_columns=[\"id\", \"note_id\"],\n    editable_columns=[\"label\", \"concept\"],\n    categorical_columns=[\"label\", \"concept\"],\n    style={\"--min-notebook-height\": \"300px\"},\n)\nnote_text_view = app.render_text(\n    view_name=\"note_text\",\n    # Where to look for text data in the app data\n    store_text_key=\"notes\",\n    text_column=\"note_text\",\n    text_pkey_column=\"note_id\",\n    # Where to look for spans data in the app data\n    store_spans_key=\"entities\",\n    spans_pkey_column=\"id\",\n    style={\"--min-notebook-height\": \"300px\"},\n    labels=labels_config,\n)\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#6-assemble-everything","title":"6) Assemble everything","text":"<p>Panels can be resized, rearranged (drag the tab handles), or hidden by docking into another panel\u2019s tab bar. The note panel header is customized to display the current note id.</p> <pre><code>app_state = app.state\napp_data = app.data\n\n@component\ndef NoteHeader():\n    doc_idx = use_store_snapshot(app_state[\"notes\"])[\"last_idx\"]\n\n    if doc_idx is None:\n        return \"Note\"\n    return f\"Note ({app_data['notes'][doc_idx]['note_id']})\"\n\nlayout = div(\n    Layout(\n        Panel(div(Markdown(DESC), style={\"margin\": \"10px\"}), key=\"Description\"),\n        Panel(notes_view, header=\"Notes\", key=\"notes\"),\n        Panel(entities_view, header=\"Entities\", key=\"entities\"),\n        Panel(note_text_view, header=NoteHeader(), key=\"note_text\"),\n        # Describe how the panels should be arranged by default\n        default_config={\n            \"kind\": \"row\",\n            \"children\": [\n                \"Description\",\n                {\"children\": [\"notes\", \"entities\"]},\n                \"note_text\",\n            ],\n        },\n        collapse_tabs_on_mobile=[\"note_text\", \"Description\", \"notes\", \"entities\"],\n    ),\n    style={\n        \"background\": \"var(--joy-palette-background-level2, #f0f0f0)\",\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n        \"minHeight\": \"300px\",\n        \"--sd-background-color\": \"transparent\",\n    },\n)\nreturn layout\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#7-render-or-serve","title":"7) Render or serve","text":"<p>You can either serve it or display it in a notebook, following the instructions in the previous section.</p> <p>JupyterLab Tabs</p> <p>In notebooks, Pret layouts cannot be \"mixed\" with JupyterLab\u2019s own UI system, and will always be embedded in a single JupyterLab tab. You may prefer displaying specific views in separate cells.</p> <p>Simply display the variables <code>notes_view</code>, <code>entities_view</code>, <code>note_text_view</code> (the return values of <code>app.render_text</code> and <code>app.render_table</code>) in different cells.</p>"},{"location":"tutorials/run-quaero-explorer/#syncing-collaboration-and-saving","title":"Syncing, collaboration, and saving","text":"<p>Metanno (via Pret) can sync app state across clients and optionally persist it.</p>"},{"location":"tutorials/run-quaero-explorer/#live-sync-only-no-persistence","title":"Live sync only (no persistence)","text":"<p>Pass <code>sync=True</code> when creating the app to enable real\u2011time collaboration without saving to disk:</p> <pre><code>app = DatasetApp(\n    {\n        \"notes\": notes,\n        \"entities\": entities,\n    },\n    sync=True,\n)\n</code></pre> <p>Open the same notebook twice or the same app URL in two tabs: edits in one tab are mirrored to the other.</p>"},{"location":"tutorials/run-quaero-explorer/#live-sync-and-saving-to-a-file","title":"Live sync and saving to a file","text":"<p>Provide a file path to append every change to an on\u2011disk log:</p> <pre><code>app = DatasetApp(\n    {\n        \"notes\": notes,\n        \"entities\": entities,\n    },\n    sync=\"quaero.bin\",\n)\n</code></pre> <p>Now changes are saved on disk, and multiple servers/kernels can collaborate by pointing to the same file.</p>"},{"location":"tutorials/run-quaero-explorer/#what-is-the-saved-format","title":"What is the saved format?","text":"<p>It\u2019s a compact, binary, append\u2011only log of user mutations: you cannot read it directly.</p> <p>To inspect it, you can create store synced with the file and read current state.</p> <pre><code>from pret.store import create_store\n\nstore = create_store(sync=\"quaero.bin\")\npure_py_object = store.to_py()\n</code></pre> <p>To export to other formats, write a small exporter from your in\u2011memory data (<code>app.data</code>). We recommend using EDS\u2011NLP data connectors since it supports several data formats and schemas.</p>"},{"location":"reference/metanno/","title":"<code>metanno</code>","text":""},{"location":"reference/metanno/recipes/","title":"<code>metanno.recipes</code>","text":""},{"location":"reference/metanno/recipes/explorer/","title":"<code>metanno.recipes.explorer</code>","text":""},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetApp","title":"<code>DatasetApp</code>","text":"<p>The <code>DatasetApp</code> is a helper class for building interactive annotation and exploration applications using Metanno components. It manages data stores, shared state, and multiple synchronized views such as tables and annotated text views.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetApp--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>data</code> <p>Initial data to populate the application. Typically, a list of dictionaries or another data structure supported by <code>create_store</code>.</p> <p> TYPE: <code>Any</code> </p> <code>sync</code> <p>Whether and how to sync and persist the data:</p> <ul> <li>False / None: no persistence (in-memory browser only).</li> <li>True: data will be synced between browser and server,   but not persisted on the server.</li> <li>str or PathLike: path where the store should be saved.   This we also enable syncing multiple notebook kernels or   server together.</li> </ul> <p> TYPE: <code>Optional[Union[bool, str, PathLike]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetApp.render_table","title":"<code>render_table</code>","text":"<p>Build and register a table view backed by the app's reactive stores.</p> <p>This helper wires a <code>Table</code> component to the data stored at <code>store_key</code>, infers column types, and synchronizes selection/filter state with other registered views in the application. The returned value is a Pret component you can mount in your layout.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetApp.render_table--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_key</code> <p>Key in the app data store (<code>self.data</code>) that contains the list of rows to display. Each row is a dictionary.</p> <p> TYPE: <code>str</code> </p> <code>pkey_column</code> <p>Column name that uniquely identifies each row. Passed to the Table as its <code>row_key</code> and used to synchronize with other views. Expect bugs and rendering issues if this column is not unique.</p> <p> TYPE: <code>str</code> </p> <code>hidden_columns</code> <p>Column names that should be hidden in the table.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>()</code> </p> <code>id_columns</code> <p>Column names rendered as hyperlinks (Table \"hyperlink\" kind). These columns are also cleared from filters when programmatic navigation occurs to avoid conflicting filters.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>()</code> </p> <code>editable_columns</code> <p>Column names that should be editable. Only string and boolean columns are allowed to be marked editable; attempting to mark other types raises an assertion.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>()</code> </p> <code>categorical_columns</code> <p>Columns to treat as discrete categories. Candidate values are inferred from the first 1000 non-null values and surfaced as input suggestions. Cells of these columns are rendered as dropdown selectors with the candidate values when edited.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>()</code> </p> <code>first_columns</code> <p>Columns that should appear first, in the provided order. Remaining columns follow in discovery order from the data.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>()</code> </p> <code>style</code> <p>Optional style dictionary forwarded to the Table component.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>view_name</code> <p>Logical name for this view. Defaults to <code>store_key</code>.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Renderable</code>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetApp.render_text","title":"<code>render_text</code>","text":"<p>Build and register a text + spans view backed by the app's reactive stores.</p> <p>This helper wires an <code>AnnotatedText</code> component to textual documents stored under <code>store_text_key</code> and span annotations stored under <code>store_spans_key</code>. It also renders a small label toolbar (optional shortcuts) to create spans from the current mouse selection. The returned value is a Pret component you can mount in your layout.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetApp.render_text--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_text_key</code> <p>Key in the app data store (<code>self.data</code>) containing a list of documents. Each document must at least provide the text column and a primary key column.</p> <p> TYPE: <code>str</code> </p> <code>store_spans_key</code> <p>Key in the app data store containing the list of span annotations. Each span must include <code>begin</code> and <code>end</code> character offsets, the document identifier (<code>text_pkey_column</code>), and its own identifier (<code>spans_pkey_column</code>).</p> <p> TYPE: <code>str</code> </p> <code>labels</code> <p>Style/behavior map for label creation and rendering. Each entry is a dict such as <code>{\"color\": \"#ffcccc\", \"shortcut\": \"A\"}</code> that is forwarded to the <code>annotation_styles</code> prop of <code>AnnotatedText</code> and used by the toolbar to add spans with the associated label. Defaults to an empty mapping.</p> <p> TYPE: <code>Optional[Dict[str, Dict[str, Any]]]</code> DEFAULT: <code>{}</code> </p> <code>text_column</code> <p>Name of the field in each text document that contains the raw text.</p> <p> TYPE: <code>str</code> </p> <code>text_pkey_column</code> <p>Name of the field in each text document that uniquely identifies the document. This is used to keep the text view and other views (tables) in sync.</p> <p> TYPE: <code>str</code> </p> <code>spans_pkey_column</code> <p>Name of the field in each span that uniquely identifies the span (used for selection/highlighting and scrolling).</p> <p> TYPE: <code>str</code> </p> <code>style</code> <p>Optional style dictionary forwarded to the AnnotatedText component (merged with sensible defaults to make the view scrollable and flexible in layouts).</p> <p> TYPE: <code>Dict[str, Any]</code> DEFAULT: <code>None</code> </p> <code>view_name</code> <p>Logical name for this view. Defaults to <code>f\"{store_text_key}:{text_column}:{store_spans_key}\"</code>.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Renderable</code>"},{"location":"reference/pret/ui/metanno/","title":"index.md","text":""},{"location":"reference/pret/ui/metanno/#pretuimetanno","title":"<code>pret.ui.metanno</code>","text":""},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedImage","title":"<code>AnnotatedImage</code>","text":"<p>An interactive image viewer that supports drawing, selecting, and styling geometric shapes (polygons, rectangles, points...) as annotations.</p> <p>Under the hood, we use Konva to render the image and its annotations.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedImage--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import AnnotatedImage\nimport time\n\n# Reactive store holding the annotation list\nimg_state = create_store([\n    {\n        \"id\": \"1\",\n        \"type\": \"polygon\",\n        \"points\": [10, 10, 50, 20],\n        \"label\": \"OBJ\",\n        \"style\": \"primary\",\n    }\n])\n\n# Style preset referenced from the annotation above\nimg_annotation_styles = {\n    \"primary\": {\n        \"strokeColor\": \"red\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"rgba(255,0,0,0.5)\",\n        \"labelPosition\": \"center\",\n        \"align\": \"center\",\n        \"verticalAlign\": \"top\",\n    },\n    \"secondary\": {\n        \"strokeColor\": \"blue\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"#0000ff80\",\n        \"textColor\": \"white\",\n    }\n}\n\n@component\ndef MyImage():\n    tracked_state = use_store_snapshot(img_state)\n\n    @use_event_callback\n    def on_mouse_select(modkeys, shapes):\n        # Toggle 'mouseSelected' flag\n        for shp in shapes:\n            img_state.append({\n                \"id\": str(time.time()),\n                \"points\": shp[\"points\"],\n                \"label\": \"OBJ\",\n                \"style\": \"primary\",\n            })\n\n    @use_event_callback\n    def on_click(shape_idx, modkeys):\n        if shape_idx is None:\n            img_state.clear()\n        else:\n            old_style = img_state[shape_idx].get(\"style\", \"primary\")\n            new_style = \"secondary\" if old_style == \"primary\" else \"primary\"\n            img_state[shape_idx][\"style\"] = new_style\n\n    return AnnotatedImage(\n        image=\"https://picsum.photos/400/300\",\n        annotations=tracked_state,\n        annotation_styles=img_annotation_styles,\n        on_mouse_select=on_mouse_select,\n        on_click=on_click,\n    )\n\nMyImage()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedImage--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>annotations</code> <p>List of annotation objects drawn on top of the image. Each annotation must contain the geometric <code>type</code> and <code>points</code> fields (defining the shape) plus optional metadata such as:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Human-readable text shown next to the shape.</li> <li><code>style</code>: Key that looks up visual properties in <code>annotation_styles</code>.</li> <li><code>selected</code> / <code>highlighted</code> / <code>mouseSelected</code>: Booleans used by the   component when rendering interaction state.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>annotation_styles</code> <p>Named style presets referenced by the <code>style</code> field of an annotation.  Each preset may define properties such as stroke color, fill color, opacity, font size, and label alignment, using the following properties:</p> <ul> <li><code>strokeColor</code> (str): Color of the shape's stroke (e.g. <code>\"#ff0000\"</code>).</li> <li><code>strokeWidth</code> (int): Width of the shape's stroke in pixels.</li> <li><code>fillColor</code> (str): Background color of the shape (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>opacity</code> (float): Opacity of the shape's fill (0.0 to 1.0).</li> <li><code>shape</code> (str): Shape type, e.g. <code>\"polygon\"</code>, <code>\"rectangle\"</code>, <code>\"circle\"</code>, etc.</li> <li><code>fontSize</code> (int): Font size for the label text.</li> <li><code>align</code> (\"left\" | \"center\" | \"right\"): Horizontal alignment of the label text.</li> <li><code>verticalAlign</code> (\"top\" | \"middle\" | \"bottom\"): Vertical alignment of the label text.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>image</code> <p>Source URL or base-64 data URI of the image to annotate.</p> <p> TYPE: <code>str</code> </p> <code>mouse_selection</code> <p>Temporary shapes being drawn by the user while the mouse button is held down.  Supplied back to <code>on_mouse_select</code> when the gesture ends.</p> <p> TYPE: <code>Any</code> </p> <code>style</code> <p>Inline CSS-compatible style overrides for the root element of the component.</p> <p> TYPE: <code>Any</code> </p> <code>actions</code> <p>Optional imperative handles (e.g. <code>actions[\"scroll_to_shape\"](idx)</code>) that the parent may call.  Reserved for future expansion.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>React key for stable reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click</code> <p>Invoked when the user clicks on an existing shape.</p> <ul> <li><code>shape_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 List of pressed modifier keys (e.g. <code>[\"Shift\"]</code>)</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_key_press</code> <p>Invoked when the component has focus and the user presses a key.</p> <ul> <li><code>key</code> \u2013 The key name (<code>\"Escape\"</code>, <code>\"Delete\"</code> \u2026)</li> <li><code>modkeys</code> \u2013 Concurrently pressed modifier keys</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_mouse_enter_shape</code> <p>Hover callbacks fired when the mouse pointer enters or leaves a shape.</p> <p> TYPE: <code>Any</code> </p> <code>on_mouse_select</code> <p>Fired after the user completes a drag selection.</p> <ul> <li><code>modkeys</code> \u2013 Modifier keys pressed during selection</li> <li><code>shapes</code> \u2013 All shapes inside the lasso / rectangle</li> </ul> <p> TYPE: <code>Any</code> </p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.Table","title":"<code>Table</code>","text":"<p>A component for displaying a table with various features such as filtering, highlighting rows, and handling cell changes.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.Table--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom pret.ui.metanno import Table\n\ntable_state = create_store([\n    {\"id\": \"1\", \"date\": \"2023-01-01\", \"text\": \"Sample text 1\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"2\", \"date\": \"2023-01-03\", \"text\": \"Sample text 2\", \"type\": \"OTHER\", \"labels\": [\"ready\", \"danger\"]},\n    {\"id\": \"3\", \"date\": \"2023-01-05\", \"text\": \"Sample text 3\", \"type\": \"ENT\", \"labels\": [\"blue\"]},\n    {\"id\": \"4\", \"date\": \"2023-01-07\", \"text\": \"Sample text 4\", \"type\": \"OTHER\", \"labels\": [\"bad\"]},\n    {\"id\": \"5\", \"date\": \"2023-01-09\", \"text\": \"Sample text 5\", \"type\": \"ENT\", \"labels\": []},\n    {\"id\": \"6\", \"date\": \"2023-01-11\", \"text\": \"Sample text 6\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"7\", \"date\": \"2023-01-13\", \"text\": \"Sample text 7\", \"type\": \"FOO\", \"labels\": [\"ready\"]},\n    {\"id\": \"8\", \"date\": \"2023-01-15\", \"text\": \"Sample text 8\", \"type\": \"FOO2\", \"labels\": [\"danger\"]},\n    {\"id\": \"9\", \"date\": \"2023-01-17\", \"text\": \"Sample text 9\", \"type\": \"FOO3\", \"labels\": [\"blue\"]},\n    {\"id\": \"10\", \"date\": \"2023-01-19\", \"text\": \"Sample text 10\", \"type\": \"ENT\", \"labels\": [\"bad\"]},\n    {\"id\": \"11\", \"date\": \"2023-01-21\", \"text\": \"Sample text 11\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"12\", \"date\": \"2023-01-23\", \"text\": \"Sample text 12\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"13\", \"date\": \"2023-01-25\", \"text\": \"Sample text 13\", \"type\": \"OTHER\", \"labels\": [\"danger\"]},\n    {\"id\": \"14\", \"date\": \"2023-01-27\", \"text\": \"Sample text 14\", \"type\": \"FOO2\", \"labels\": [\"blue\"]},\n    {\"id\": \"15\", \"date\": \"2023-01-29\", \"text\": \"Sample text 15\", \"type\": \"FOO3\", \"labels\": [\"bad\"]},\n])\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"date\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True, \"editable\": True},\n    {\"key\": \"type\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\", \"STUFF\", \"FOO\", \"FOO2\", \"FOO3\"]},\n    {\"key\": \"labels\", \"kind\": \"multi-text\", \"name\": \"labels\", \"filterable\": True, \"editable\": True, \"choices\": [\"ready\", \"danger\", \"blue\", \"bad\", \"custom\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        table_state[row_idx][col] = new_value\n\n    view_state = use_store_snapshot(table_state)\n    return Table(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.Table--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>columns</code> <p>The columns to display in the table:</p> <ul> <li><code>key</code>: Unique identifier for the column.</li> <li><code>name</code>: Display name of the column.</li> <li><code>kind</code>: Type of data in the column (e.g., \"text\", \"hyperlink\", \"multi-text\", \"boolean\", ...).</li> <li><code>editable</code>: Whether the column is editable.</li> <li><code>filterable</code>: Whether the column can be filtered.</li> <li><code>choices</code>: Optional list of choices for the column (if applicable).</li> </ul> <p> TYPE: <code>ColumnData</code> </p> <code>filters</code> <p>The current filters applied to the table, mapping column keys to filter values.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>highlighted_rows</code> <p>List of row indices that should be highlighted.</p> <p> TYPE: <code>List[int]</code> </p> <code>row_key</code> <p>The key used to uniquely identify each row in the table.</p> <p> TYPE: <code>str</code> </p> <code>rows</code> <p>The data for each row in the table, where each row is a dictionary mapping column keys to their values.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>actions</code> <p>Actions that can be performed on the table, such as scrolling.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>auto_filter</code> <p>Whether to automatically apply filters as the user types.</p> <p> TYPE: <code>bool</code> </p> <code>input_value</code> <p>The current input value to show in the input field when the user is editing a cell. If undefined, this is automatically handled by the component.</p> <p> TYPE: <code>Union[str, Hyperlink]</code> </p> <code>suggestions</code> <p>List of suggestions to show when the user is typing in the input field.</p> <p> TYPE: <code>List[Any]</code> </p> <code>position</code> <p>The current position of the cursor in the table, including:</p> <ul> <li>row_idx: Index of the row where the cursor is located.</li> <li>col: Key of the column where the cursor is located.</li> <li>mode: Mode of interaction, either \"EDIT\" or \"SELECT\".</li> </ul> <p> TYPE: <code>Position</code> </p> <code>style</code> <p>Custom styles for the table component.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>A unique key for the component instance, used for React's reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_input_change</code> <p>Callback triggered when the input value changes in a cell. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value entered by the user.</li> <li><code>cause</code>: Reason for the change (e.g., \"blur\", \"enter\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_scroll_bottom</code> <p>Callback triggered when the user scrolls to the bottom of the table. Will be called with the following parameters:</p> <ul> <li><code>event</code>: Scroll event or a dictionary indicating if the user is at the bottom.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_cell_change</code> <p>Callback triggered when a cell's value changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value of the cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_click_cell_content</code> <p>Callback triggered when the content of a cell is clicked (like a hyperlink). Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row containing the clicked cell.</li> <li><code>name</code>: Key of the column containing the clicked cell.</li> <li><code>value</code>: Optional value of the clicked cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_filters_change</code> <p>Callback triggered when filters are updated. Will be called with the following parameters:</p> <ul> <li><code>values</code>: Dictionary mapping column keys to filter values.</li> <li><code>column</code>: Key of the column being filtered.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_enter_row</code> <p>Callback triggered when the mouse enters a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_leave_row</code> <p>Callback triggered when the mouse leaves a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_position_change</code> <p>Callback triggered when the cursor position changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>name</code>: Key of the column where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>mode</code>: Interaction mode, either \"EDIT\" or \"SELECT\".</li> <li><code>cause</code>: Reason for the position change (e.g., \"key\", \"blur\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_subset_change</code> <p>Callback triggered when the subset of visible rows changes. Will be called with the following parameters:</p> <ul> <li><code>subset</code>: List of indices representing the new subset of rows.</li> </ul> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedText","title":"<code>AnnotatedText</code>","text":"<p>The <code>AnnotatedText</code> is a rich text viewer that supports span-level annotations, nested token highlights, and various user event callbacks.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedText--examples","title":"Examples","text":"<pre><code>from pret import (\n    component,\n    create_store,\n    use_store_snapshot,\n    use_event_callback,\n    use_state,\n)\nfrom pret.ui.metanno import AnnotatedText\nfrom pret.ui.joy import Button, Box\n\ntxt = (\n    \"Metanno brings annotation components to Pret\\n\"\n    \"to build tailored annotation tools.\"\n)\n\n# One span covering the word \u201cMetanno\u201d\nspans = create_store(\n    [\n        {\n            \"id\": f\"span-0-7\",\n            \"begin\": 0,\n            \"end\": 7,\n            \"label\": \"OBJ\",\n            \"highlighted\": False,\n        }\n    ]\n)\n\ntxt_annotation_styles = create_store(\n    {\n        \"OBJ\": {\n            \"color\": \"red\",\n            \"shape\": \"underline\",\n        }\n    }\n)\n\n\n@component\ndef MyText():\n    tracked_spans = use_store_snapshot(spans)\n    tracked_styles = use_store_snapshot(txt_annotation_styles)\n\n    @use_event_callback\n    def handle_select(ranges, modkeys):\n        for sp in ranges:\n            spans.extend(\n                [\n                    {\n                        \"id\": f\"span-{sp['begin']}-{sp['end']}\",\n                        \"begin\": sp[\"begin\"],\n                        \"end\": sp[\"end\"],\n                        \"label\": \"OBJ\",\n                    }\n                ]\n            )\n\n    def on_mouse_enter_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = True\n\n    def on_mouse_leave_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = False\n\n    def on_span_style_change():\n        old_style = txt_annotation_styles[\"OBJ\"][\"shape\"]\n        new_style = \"box\" if old_style == \"underline\" else \"underline\"\n        txt_annotation_styles[\"OBJ\"][\"shape\"] = new_style\n\n    return Box(\n        Button(\"Change style\", on_click=on_span_style_change),\n        Button(\"Remove annotations\", on_click=lambda: spans.clear()),\n        AnnotatedText(\n            text=txt,\n            spans=tracked_spans,\n            annotation_styles=tracked_styles,\n            on_mouse_select=handle_select,\n            on_mouse_enter_span=on_mouse_enter_span,\n            on_mouse_leave_span=on_mouse_leave_span,\n            style={\"gridColumn\": \"1 / -1\"},\n        ),\n        sx={\n            \"p\": 1,\n            \"display\": \"grid\",\n            \"gridTemplateColumns\": \"repeat(2, auto)\",\n            \"gap\": 1,\n        },\n    )\n\n\nMyText()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.AnnotatedText--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>text</code> <p>Raw text content shown in the viewer.</p> <p> TYPE: <code>str</code> </p> <code>spans</code> <p>Span-level annotations over <code>text</code>.  Each span must include <code>begin</code> and <code>end</code> character offsets, with optional fields:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Category name displayed next to / above the span.</li> <li><code>style</code>: Key referencing <code>annotation_styles</code>.</li> <li><code>selected</code> (bool): styled as selected by the user.</li> <li><code>highlighted</code> (bool): styled as highlighted by the user.</li> </ul> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>annotation_styles</code> <p>Named style presets that control span background color, border, label placement, etc. Each style may define properties such as:</p> <ul> <li><code>color</code> (str): Color of the span. Will be overridden by <code>backgroundColor</code> and <code>borderColor</code>.</li> <li><code>shape</code> (\"underline\" | \"box\"): Visual style of the span.</li> <li><code>backgroundColor</code> (str): Background color of the span (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>borderColor</code> (str): Border color of the span (e.g. <code>\"#000000\"</code>).</li> <li><code>autoNestingLayout</code> (bool): Whether to automatically nest overlapping spans, rather than rendering them on top of each other.</li> </ul> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> <code>mouse_selection</code> <p>Current mouse drag selection expressed as character\u2010offset ranges. Passed to <code>on_mouse_select</code> when the action completes.</p> <p> TYPE: <code>List[Dict[str, int]]</code> </p> <code>style</code> <p>CSS style overrides for the outer element.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>actions</code> <p>Optional imperative helpers (<code>scroll_to_span</code> \u2026, <code>clear_current_mouse_selection</code>).</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>React reconciliation key.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click_span</code> <p>Called when the user clicks on a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_key_press</code> <p>Called when a key is pressed with focus inside the component.</p> <ul> <li><code>key</code> \u2013 Key name</li> <li><code>ranges</code> \u2013 Current selection ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[Dict[str, int]], List[str]], None]</code> </p> <code>on_mouse_enter_span</code> <p>Called when the mouse pointer enters a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the span entered</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_leave_span</code> <p>Called when the mouse pointer leaves a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the span left</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_select</code> <p>Triggered when the user finishes selecting text with the mouse.</p> <ul> <li><code>ranges</code> \u2013 Final list of selected ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[Dict[str, int]], List[str]], None]</code> </p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Improved visibility of highlighted spans and layout of boxes with mixed inset/outset nesting</li> <li>Improved autocompletion experience for table suggestion inputs</li> <li>Improved tokenization of text, now allowed to split around dashes (-).</li> <li>Added theoretical support for touch screens (lightly tested)</li> <li>Added tutorials<ul> <li>Setup</li> <li>Run the Quaero Explorer app</li> <li>Customize the explorer</li> </ul> </li> </ul>"},{"location":"changelog/#v100beta1","title":"v1.0.0.beta1","text":"<ul> <li>Complete refacto of the framework: the Python-JS synchronized app mechanisms have been moved to a new library: Pret !</li> <li>Text and Table components are now callable directly from python, along other components built around MUI Joy. This gives the user the ability to easily build simple apps, and iterate on the design step by step.</li> <li>Metanno now features new Image annotation component.</li> <li>The tests run in Python 3.7 - 3.10, using playwright in headless Firefox, Chrome and Webkit.</li> <li>Metanno now also has a nice interactive documentation !</li> </ul>"},{"location":"changelog/#metanno-v0","title":"Metanno v0","text":"<p>Metanno v0 is a JupyterLab extension for building custom annotation interfaces. It focuses on textual documents with structured entities and aims for modularity, customization, and interactivity. Core features include multi-line and nested span annotations, table-based relational annotations, multiple data types (hyperlinks, text, lists), and an immutable state that can be synchronized between the frontend and backend. The project compiles Python app classes to JavaScript using Transcrypt, enabling fast, browser-side execution while keeping Python code on the kernel side. To create an app, the user must modify one of the apps in recipes/*.py, and handle state management using a huge Redux-style reducer in <code>select_state</code>.</p> <p>Last items in the v0 changelog:</p> <ul> <li>Almost complete typescript conversion</li> <li>Added column filters</li> <li>Customizable undo/redo logic</li> <li>Editable span annotations from a table view</li> <li>Accessible return value of a Python call from front end (async calls)</li> </ul>"}]}