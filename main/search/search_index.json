{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#_1","title":"","text":"<p>Metanno is a Python library built on top of the Pret framework for building dynamic, customizable annotation interfaces.</p> <p>Who is it for? Research groups, clinical NLP and biomedical teams, data labeling squads, and anyone who wants custom and interactive annotation tools without wrestling with JavaScript.</p> <p>Metanno currently focuses on text and images with richly structured entities. Its goals are:</p> <ul> <li>Modularity: show your data from multiple synchronized angles. For example, highlight entities over text or images while editing the same rows in a table.</li> <li>Python\u2011first UI: write the entire app in Python; it renders to a fast React UI under the hood.</li> <li>Interactivity: handle annotations as plain Python objects at any time, so you can create, inspect, and transform them programmatically.</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#annotate-anything","title":"Annotate anything","text":"<p>In addition to the Pret ecosystem component suite, Metanno provides components for common annotation views:</p> <ul> <li>AnnotatedText: display text with highlighted, nestable spans</li> <li>AnnotatedImage: draw shapes (boxes, polygons, etc.) over images.</li> <li>Table: an editable, filterable spreadsheet\u2011style grid for inspecting and editing annotations.</li> </ul> <p>You can compose these views of the same underlying annotations to get a better grasp of the data you are annotating or inspecting.</p>"},{"location":"#run-it-your-way","title":"Run it your way","text":"<p>Use Metanno in two modes:</p> <ul> <li>Standalone app: run a server and use it in your browser.</li> <li>JupyterLab widgets: embed components directly in notebooks, with no extra ports or separate server process.</li> </ul> <p>Develop and test in a notebook. If you prefer, you can also run it as a standalone app.</p>"},{"location":"#easy-setup","title":"Easy setup","text":"<pre><code>pip install metanno==1.0.0-beta.6\n</code></pre> <p>To use it with Jupyter, if you install the library in a custom environment (conda, venv, or other), you will likely need to tell Jupyter where to find the front-end files. You can do this by running the following command (only once), and restart your Jupyterlab server:</p> <pre><code>pret update-jupyter-config --apply\n</code></pre> <p>Unlike other alternatives, Metanno requires no additional ports and no separate server process when used in JupyterLab. Write your app in Python and benefit from a fast React front end under the hood.</p>"},{"location":"#interactive-and-customizable-by-design","title":"Interactive and customizable by design","text":"<ul> <li>Inspect and edit application state directly from Python.</li> <li>Update the UI from Python; execute a notebook cell to see changes immediately.</li> <li>Register event handlers for clicks, hovers, keystrokes, and more.</li> </ul>"},{"location":"#why-another-annotation-software","title":"Why another annotation software?","text":"<p>Tool choice shapes both the annotation scheme and the workflow. In many out\u2011of\u2011the\u2011box tools, tasks like annotating implicit or document\u2011level entities, working across multiple documents at once, or coordinating multiple views can be difficult or unsupported. There are many available solutions (see Neves et al.). However,  most of these are either proprietary, poorly adapted to document or multi-document annotation, require a complex installation that is not compatible with existing strict remote computing environments, or are difficult to customize.</p> <p>Metanno takes a different approach: a modular, Python\u2011first framework that adapts to your schema and to your annotation process, instead of forcing you into fixed layers or rigid UIs.</p>"},{"location":"#demo","title":"Demo","text":"<p>See the demo apps, listed below.</p> <p> Quaero Explorer</p><p>Explore and edit the Quaero dataset.</p>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Check out the tutorials to get started with Metanno !</p> <p> Set up a new project</p><p>Learn how to install Metanno in a new project or add it to an existing one.</p><p> Run the Data Explorer demo</p><p>Run the Quaero Explorer demo app and discover the features of the DataWidgetFactory: persisting annotations, collaborating, and more.</p><p> Adding custom fields</p><p>Learn how to extend the data model and expose custom fields in table, text, and form widgets.</p><p> Pre-annotate Data with EDS-NLP</p><p>Use EDS-NLP to pre-annotate your data.</p><p> Nested and Linked Collections</p><p>Structure multi-level datasets with nested paths or linked collections.</p>"},{"location":"#small-example","title":"Small example","text":"<p>Below is a small example that lets you annotate text spans and view them in a synchronized table. Select spans to add them; hold Shift (also labeled Maj on some keyboards) while selecting to delete overlapping spans.</p> Show code <pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom metanno import AnnotatedText\n\nstate = create_store(\n    [\n        {\"text\": \"soir\", \"begin\": 3, \"end\": 7, \"id\": \"s-3-7\", \"label\": \"ENT\"},\n        {\"text\": \"Charlie\", \"begin\": 59, \"end\": 66, \"id\": \"s-59-66\", \"label\": \"ENT\"},\n    ]\n)\n\ntext = (\n    \"Le soir, apr\u00e8s avoir mang\u00e9 sa soupe aux choux noy\u00e9e \"\n    \"d\u2019eau, Charlie allait toujours dans la chambre de ses \"\n    \"quatre grands-parents pour \u00e9couter leurs histoires, \"\n    \"et pour leur souhaiter bonne nuit.\\n\"\n    \"Chacun d\u2019eux avait plus de quatre-vingt-dix ans. Ils \"\n    \"\u00e9taient frip\u00e9s comme des pruneaux secs, ossus comme \"\n    \"des squelettes et, toute la journ\u00e9e, jusqu\u2019\u00e0 l\u2019apparition \"\n    \"de Charlie, ils se pelotonnaient dans leur lit, deux de \"\n    \"chaque c\u00f4t\u00e9, coiff\u00e9s de bonnets de nuit qui leur tenaient \"\n    \"chaud, passant le temps \u00e0 ne rien faire.\"\n)\n\n\n@component\ndef App():\n    view_state = use_store_snapshot(state)\n\n    @use_event_callback\n    def on_select(spans, mod_keys):\n        if \"Shift\" in mod_keys:\n            # Delete overlapped spans if the user holds Shift\n            state[:] = [\n                x\n                for x in state\n                if any(\n                    (s[\"begin\"] &gt;= x[\"end\"] or s[\"end\"] &lt;= x[\"begin\"]) for s in spans\n                )\n            ]\n        else:\n            state.extend(\n                [\n                    {\n                        **s,\n                        \"id\": f\"s-{s['begin']}-{s['end']}\",\n                        \"text\": text[s[\"begin\"] : s[\"end\"]],\n                        \"label\": \"ENT\",\n                    }\n                    for s in spans\n                ]\n            )\n\n    return AnnotatedText(\n        text=text,\n        spans=view_state,\n        annotation_styles={\"ENT\": {\"color\": \"lightblue\"}},\n        on_mouse_select=on_select,\n    )\n\n\nApp()\n</code></pre> <p>The annotations are reflected in the table below. Both views stay in sync because they share the same state (<code>state</code>).</p> Show code <pre><code># \u2191 Complete the code above with the following snippet \u2191\nfrom pret import component, use_store_snapshot, use_event_callback\nfrom metanno import Table\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"begin\", \"kind\": \"text\", \"name\": \"begin\", \"filterable\": True},\n    {\"key\": \"end\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True},\n    {\"key\": \"label\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True,\n        \"editable\": True, \"choices\": [\"ENT\", \"OTHER\"]},\n]\n\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        view_state[row_idx][col] = new_value\n\n    for x in state:\n        x.setdefault(\"label\", \"ENT\")  # Ensure all rows have a label\n\n    view_state = use_store_snapshot(state)\n    return Table(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\n\nMyTable()\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#as-a-user","title":"As a user","text":"<p>A simple pip installation should be enough to install Metanno both as a standalone web app framework and as a JupyterLab extension:</p> <pre><code>pip install metanno==1.0.0-beta.6\n</code></pre> <p>To use it with Jupyter, if you install the library in a custom environment (conda, venv, or other), you will likely need to tell Jupyter where to find the front-end files. You can do this by running the following command (only once), and restart your Jupyterlab server:</p> <pre><code>pret update-jupyter-config --apply\n</code></pre>"},{"location":"installation/#as-a-contributor","title":"As a contributor","text":"<p>If you want to contribute to Metanno, you should have a programming environment:</p> <ul> <li>Python 3.7 or later, with pip and hatch installed</li> <li>Node.js 20 or later (you can use nvm to easily install and manage Node.js versions)</li> <li>JupyterLab 3 (the built extension will be compatible with JupyterLab 4)</li> <li>Various web browsers for testing (e.g., Chrome, Firefox, Safari)</li> <li>A Git client to clone the repository and manage your changes</li> </ul> <pre><code>git clone https://github.com/percevalw/metanno.git\ncd metanno\n</code></pre> <p>Then, create a new branch for your changes:</p> <pre><code>git checkout -b my-feature-branch\n</code></pre> <p>Create (optional) virtual env and install all development deps. Install the package in editable mode with development dependencies:</p> <pre><code>yarn install\npip install -e . --group dev  #(1)!\nyarn playwright install --with-deps # browsers for UI tests\n</code></pre> <ol> <li>or <code>uv pip install -e . --group dev</code> with uv</li> </ol>"},{"location":"installation/#running-the-ui-tests","title":"Running the UI tests","text":"<p>Metanno uses playwright to test the JupyterLab extension (which should cover most of the app features). You can run the tests to ensure everything is working correctly.</p> <pre><code>sh tests/jupyter/run.sh #(1)!\n</code></pre> <ol> <li>or <code>uv run sh tests/jupyter/run.sh</code> with uv</li> </ol>"},{"location":"installation/#building-the-documentation","title":"Building the documentation","text":"<p>The documentation is built with MkDocs and MkDocs Material theme, along with quite a few customizations. To build the documentation, you can use the following command:</p> <pre><code>pip install -e . --group docs  #(1)!\nmkdocs serve  #(2)!\n</code></pre> <ol> <li>or <code>uv pip install -e . --group docs</code> with uv</li> <li>or <code>uv run mkdocs serve</code> with uv</li> </ol> <ol></ol>"},{"location":"components/","title":"Building Blocks of Metanno","text":"<p>This page provides an overview of the base components available in Metanno.</p> Component Description AnnotatedText View and interact with a text with optional annotations. AnnotatedImage View and interact with an image with optional annotations. Table View and interact with a table"},{"location":"components/annotated-image/","title":"AnnotatedImage","text":""},{"location":"components/annotated-image/#metanno.ui.AnnotatedImage","title":"AnnotatedImage","text":"<p>An interactive image viewer that supports drawing, selecting, and styling geometric shapes (polygons, rectangles, points...) as annotations.</p> <p>Under the hood, we use Konva to render the image and its annotations.</p>"},{"location":"components/annotated-image/#metanno.ui.AnnotatedImage--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom metanno import AnnotatedImage\nimport time\n\n# Reactive store holding the annotation list\nimg_state = create_store([\n    {\n        \"id\": \"1\",\n        \"type\": \"polygon\",\n        \"points\": [10, 10, 50, 20],\n        \"label\": \"OBJ\",\n        \"style\": \"primary\",\n    }\n])\n\n# Style preset referenced from the annotation above\nimg_annotation_styles = {\n    \"primary\": {\n        \"strokeColor\": \"red\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"rgba(255,0,0,0.5)\",\n        \"labelPosition\": \"center\",\n        \"align\": \"center\",\n        \"verticalAlign\": \"top\",\n    },\n    \"secondary\": {\n        \"strokeColor\": \"blue\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"#0000ff80\",\n        \"textColor\": \"white\",\n    }\n}\n\n@component\ndef MyImage():\n    tracked_state = use_store_snapshot(img_state)\n\n    @use_event_callback\n    def on_mouse_select(modkeys, shapes):\n        # Toggle 'mouseSelected' flag\n        for shp in shapes:\n            img_state.append({\n                \"id\": str(time.time()),\n                \"points\": shp[\"points\"],\n                \"label\": \"OBJ\",\n                \"style\": \"primary\",\n            })\n\n    @use_event_callback\n    def on_click(shape_idx, modkeys):\n        if shape_idx is None:\n            img_state.clear()\n        else:\n            old_style = img_state[shape_idx].get(\"style\", \"primary\")\n            new_style = \"secondary\" if old_style == \"primary\" else \"primary\"\n            img_state[shape_idx][\"style\"] = new_style\n\n    return AnnotatedImage(\n        image=\"https://picsum.photos/400/300\",\n        annotations=tracked_state,\n        annotation_styles=img_annotation_styles,\n        on_mouse_select=on_mouse_select,\n        on_click=on_click,\n    )\n\nMyImage()\n</code></pre>"},{"location":"components/annotated-image/#metanno.ui.AnnotatedImage--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>annotations</code> <p>List of annotation objects drawn on top of the image. Each annotation must contain the geometric <code>type</code> and <code>points</code> fields (defining the shape) plus optional metadata such as:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Human-readable text shown next to the shape.</li> <li><code>style</code>: Key that looks up visual properties in <code>annotation_styles</code>.</li> <li><code>selected</code> / <code>highlighted</code> / <code>mouseSelected</code>: Booleans used by the   component when rendering interaction state.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>annotation_styles</code> <p>Named style presets referenced by the <code>style</code> field of an annotation.  Each preset may define properties such as stroke color, fill color, opacity, font size, and label alignment, using the following properties:</p> <ul> <li><code>strokeColor</code> (str): Color of the shape's stroke (e.g. <code>\"#ff0000\"</code>).</li> <li><code>strokeWidth</code> (int): Width of the shape's stroke in pixels.</li> <li><code>fillColor</code> (str): Background color of the shape (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>opacity</code> (float): Opacity of the shape's fill (0.0 to 1.0).</li> <li><code>shape</code> (str): Shape type, e.g. <code>\"polygon\"</code>, <code>\"rectangle\"</code>, <code>\"circle\"</code>, etc.</li> <li><code>fontSize</code> (int): Font size for the label text.</li> <li><code>align</code> (\"left\" | \"center\" | \"right\"): Horizontal alignment of the label text.</li> <li><code>verticalAlign</code> (\"top\" | \"middle\" | \"bottom\"): Vertical alignment of the label text.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>image</code> <p>Source URL or base-64 data URI of the image to annotate.</p> <p> TYPE: <code>str</code> </p> <code>mouse_selection</code> <p>Temporary shapes being drawn by the user while the mouse button is held down.  Supplied back to <code>on_mouse_select</code> when the gesture ends.</p> <p> TYPE: <code>Any</code> </p> <code>style</code> <p>Inline CSS-compatible style overrides for the root element of the component.</p> <p> TYPE: <code>Any</code> </p> <code>handle</code> <p>Optional imperative handle that the parent may call (empty for now).</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>React key for stable reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click</code> <p>Invoked when the user clicks on an existing shape.</p> <ul> <li><code>shape_id</code>: Identifier of the clicked annotation</li> <li><code>modkeys</code>: List of pressed modifier keys (e.g. <code>[\"Shift\"]</code>)</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_key_press</code> <p>Invoked when the component has focus and the user presses a key.</p> <ul> <li><code>key</code>: The key name (<code>\"Escape\"</code>, <code>\"Delete\"</code> \u2026)</li> <li><code>modkeys</code>: Concurrently pressed modifier keys</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_mouse_enter_shape</code> <p>Hover callbacks fired when the mouse pointer enters or leaves a shape.</p> <p> TYPE: <code>Any</code> </p> <code>on_mouse_select</code> <p>Fired after the user completes a drag selection.</p> <ul> <li><code>modkeys</code>: Modifier keys pressed during selection</li> <li><code>shapes</code>: All shapes inside the lasso / rectangle</li> </ul> <p> TYPE: <code>Any</code> </p>"},{"location":"components/annotated-text/","title":"AnnotatedText","text":""},{"location":"components/annotated-text/#metanno.ui.AnnotatedText","title":"AnnotatedText","text":"<p>The <code>AnnotatedText</code> is a rich text viewer that supports span-level annotations, nested token highlights, and various user event callbacks.</p>"},{"location":"components/annotated-text/#metanno.ui.AnnotatedText--examples","title":"Examples","text":"<pre><code>from pret import (\n    component,\n    create_store,\n    use_store_snapshot,\n    use_event_callback,\n    use_state,\n)\nfrom metanno import AnnotatedText\nfrom pret_joy import Button, Box\n\ntxt = (\n    \"Metanno brings annotation components to Pret\\n\"\n    \"to build tailored annotation tools.\"\n)\n\n# One span covering the word \u201cMetanno\u201d\nspans = create_store(\n    [\n        {\n            \"id\": f\"span-0-7\",\n            \"start\": 0,\n            \"end\": 7,\n            \"label\": \"OBJ\",\n            \"highlighted\": False,\n        }\n    ]\n)\n\ntxt_annotation_styles = create_store(\n    {\n        \"OBJ\": {\n            \"color\": \"red\",\n            \"shape\": \"underline\",\n        }\n    }\n)\n\n\n@component\ndef MyText():\n    tracked_spans = use_store_snapshot(spans)\n    tracked_styles = use_store_snapshot(txt_annotation_styles)\n\n    @use_event_callback\n    def handle_select(ranges, modkeys):\n        for sp in ranges:\n            spans.extend(\n                [\n                    {\n                        \"id\": f\"span-{sp['begin']}-{sp['end']}\",\n                        \"start\": sp[\"begin\"],\n                        \"end\": sp[\"end\"],\n                        \"label\": \"OBJ\",\n                    }\n                ]\n            )\n\n    def on_mouse_enter_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = True\n\n    def on_mouse_leave_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = False\n\n    def on_span_style_change():\n        old_style = txt_annotation_styles[\"OBJ\"][\"shape\"]\n        new_style = \"box\" if old_style == \"underline\" else \"underline\"\n        txt_annotation_styles[\"OBJ\"][\"shape\"] = new_style\n\n    return Box(\n        Button(\"Change style\", on_click=on_span_style_change),\n        Button(\"Remove annotations\", on_click=lambda: spans.clear()),\n        AnnotatedText(\n            text=txt,\n            spans=tracked_spans,\n            annotation_styles=tracked_styles,\n            label_formatter=lambda span: f\"{span['label']} ({span['end'] - span['start']} chars)\",\n            on_mouse_select=handle_select,\n            on_mouse_enter_span=on_mouse_enter_span,\n            on_mouse_leave_span=on_mouse_leave_span,\n            style={\"gridColumn\": \"1 / -1\"},\n            begin_key=\"start\",  # Custom field names\n        ),\n        sx={\n            \"p\": 1,\n            \"display\": \"grid\",\n            \"gridTemplateColumns\": \"repeat(2, auto)\",\n            \"gap\": 1,\n        },\n    )\n\n\nMyText()\n</code></pre>"},{"location":"components/annotated-text/#metanno.ui.AnnotatedText--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>text</code> <p>Raw text content shown in the viewer.</p> <p> TYPE: <code>str</code> </p> <code>spans</code> <p>Span-level annotations over <code>text</code>.  Each span must include:</p> <ul> <li><code>begin</code> (or the value of <code>begin_key</code>): Begin character offset (inclusive).</li> <li><code>end</code> (or the value of <code>end_key</code>): End character offset (exclusive).</li> </ul> <p>and may optionally include:</p> <ul> <li><code>id</code> (or the value of <code>primary_key</code>): Optional unique span identifier.</li> <li><code>label</code> (or the value of <code>label_key</code>): Category name displayed next to / above the span.</li> <li><code>style</code> (or the value of <code>style_key</code>): Key referencing <code>annotation_styles</code>.</li> <li><code>selected</code> (or the value of <code>selected_key</code>): styled as selected by the user.</li> <li><code>highlighted</code> (or the value of <code>label_key</code>): styled as highlighted by the user.</li> </ul> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>annotation_styles</code> <p>Named style presets that control span background color, border, label placement, etc. Each style may define properties such as:</p> <ul> <li><code>color</code> (str): Color of the span. Will be overridden by <code>backgroundColor</code> and <code>borderColor</code>.</li> <li><code>shape</code> (\"underline\" | \"box\"): Visual style of the span.</li> <li><code>backgroundColor</code> (str): Background color of the span (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>borderColor</code> (str): Border color of the span (e.g. <code>\"#000000\"</code>).</li> <li><code>autoNestingLayout</code> (bool): Whether to automatically nest overlapping spans, rather than rendering them on top of each other.</li> </ul> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> <code>mouse_selection</code> <p>Current mouse drag selection expressed as character\u2010offset ranges. Passed to <code>on_mouse_select</code> when the action completes.</p> <p> TYPE: <code>List[Dict[str, int]]</code> </p> <code>style</code> <p>CSS style overrides for the outer element.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>handle</code> <p>Imperative handle for actions that can be performed on the component:</p> <ul> <li><code>scroll_to_line(line_idx: int, behavior: \"smooth\" | \"instant\" | \"auto\")</code>: Scrolls to the given line index.</li> <li><code>scroll_to_span(span_id: str, behavior: \"smooth\" | \"instant\" | \"auto\")</code>: Scrolls to the given span.</li> <li><code>clear_current_mouse_selection()</code>: Clears the current mouse selection.</li> </ul> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>begin_key</code> <p>Name of the field in <code>spans</code> that contains the begin character offset.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'begin'</code> </p> <code>end_key</code> <p>Name of the field in <code>spans</code> that contains the end character offset.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'end'</code> </p> <code>primary_key</code> <p>Name of the field in <code>spans</code> that contains the unique span identifier.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'id'</code> </p> <code>label_key</code> <p>Name of the field in <code>spans</code> that contains the human-readable label.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'label'</code> </p> <code>label_formatter</code> <p>Optional function used to compute each displayed span label from the full span dictionary. When provided, its return value is shown instead of the uppercased value from <code>label_key</code>.</p> <p> TYPE: <code>Optional[Callable[[Dict[str, Any]], str]]</code> DEFAULT: <code>None</code> </p> <code>style_key</code> <p>Name of the field in <code>spans</code> that contains the style key. This key will be used to look up visual properties in <code>annotation_styles</code>. If no style field is provided for a span, the style key will default to <code>label</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'style'</code> </p> <code>highlighted_key</code> <p>Name of the field in <code>spans</code> that indicates whether the span is highlighted.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'highlighted'</code> </p> <code>on_click_span</code> <p>Called when the user clicks on a span.</p> <ul> <li><code>span_id</code>: Identifier of the clicked annotation</li> <li><code>modkeys</code>: Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_key_press</code> <p>Called when a key is pressed with focus inside the component.</p> <ul> <li><code>key</code>: Key name</li> <li><code>ranges</code>: Current selection ranges</li> <li><code>modkeys</code>: Modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[Dict[str, int]], List[str]], None]</code> </p> <code>on_mouse_enter_span</code> <p>Called when the mouse pointer enters a span.</p> <ul> <li><code>span_id</code>: Identifier of the span entered</li> <li><code>modkeys</code>: Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_leave_span</code> <p>Called when the mouse pointer leaves a span.</p> <ul> <li><code>span_id</code>: Identifier of the span left</li> <li><code>modkeys</code>: Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_hover_spans</code> <p>Triggered every time the set of hovered spans changes.</p> <ul> <li><code>span_ids</code>: List of currently hovered span identifiers</li> <li><code>modkeys</code>: Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[str], List[str]], None]</code> </p> <code>on_mouse_select</code> <p>Triggered when the user finishes selecting text with the mouse.</p> <ul> <li><code>ranges</code>: Final list of selected ranges</li> <li><code>modkeys</code>: Modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[Dict[str, int]], List[str]], None]</code> </p> <code>key</code> <p>React reconciliation key (not the same as the previous <code>_key</code> props), this should be used to uniquely identify the component instance if there are multiple instances next to each other.</p> <p> TYPE: <code>Union[str, int]</code> </p>"},{"location":"components/table/","title":"Table","text":""},{"location":"components/table/#metanno.ui.Table","title":"Table","text":"<p>A component for displaying a table with various features such as filtering, highlighting rows, and handling cell changes.</p>"},{"location":"components/table/#metanno.ui.Table--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom metanno import Table\n\ntable_state = create_store([\n    {\"id\": \"1\", \"date\": \"2023-01-01\", \"text\": \"Sample text 1\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"2\", \"date\": \"2023-01-03\", \"text\": \"Sample text 2\", \"type\": \"OTHER\", \"labels\": [\"ready\", \"danger\"]},\n    {\"id\": \"3\", \"date\": \"2023-01-05\", \"text\": \"Sample text 3\", \"type\": \"ENT\", \"labels\": [\"blue\"]},\n    {\"id\": \"4\", \"date\": \"2023-01-07\", \"text\": \"Sample text 4\", \"type\": \"OTHER\", \"labels\": [\"bad\"]},\n    {\"id\": \"5\", \"date\": \"2023-01-09\", \"text\": \"Sample text 5\", \"type\": \"ENT\", \"labels\": []},\n    {\"id\": \"6\", \"date\": \"2023-01-11\", \"text\": \"Sample text 6\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"7\", \"date\": \"2023-01-13\", \"text\": \"Sample text 7\", \"type\": \"FOO\", \"labels\": [\"ready\"]},\n    {\"id\": \"8\", \"date\": \"2023-01-15\", \"text\": \"Sample text 8\", \"type\": \"FOO2\", \"labels\": [\"danger\"]},\n    {\"id\": \"9\", \"date\": \"2023-01-17\", \"text\": \"Sample text 9\", \"type\": \"FOO3\", \"labels\": [\"blue\"]},\n    {\"id\": \"10\", \"date\": \"2023-01-19\", \"text\": \"Sample text 10\", \"type\": \"ENT\", \"labels\": [\"bad\"]},\n    {\"id\": \"11\", \"date\": \"2023-01-21\", \"text\": \"Sample text 11\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"12\", \"date\": \"2023-01-23\", \"text\": \"Sample text 12\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"13\", \"date\": \"2023-01-25\", \"text\": \"Sample text 13\", \"type\": \"OTHER\", \"labels\": [\"danger\"]},\n    {\"id\": \"14\", \"date\": \"2023-01-27\", \"text\": \"Sample text 14\", \"type\": \"FOO2\", \"labels\": [\"blue\"]},\n    {\"id\": \"15\", \"date\": \"2023-01-29\", \"text\": \"Sample text 15\", \"type\": \"FOO3\", \"labels\": [\"bad\"]},\n])\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"date\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True, \"editable\": True},\n    {\"key\": \"type\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\", \"STUFF\", \"FOO\", \"FOO2\", \"FOO3\"]},\n    {\"key\": \"labels\", \"kind\": \"multi-text\", \"name\": \"labels\", \"filterable\": True, \"editable\": True, \"choices\": [\"ready\", \"danger\", \"blue\", \"bad\", \"custom\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_id, row_idx, col, new_value):\n        table_state[row_idx][col] = new_value\n\n    view_state = use_store_snapshot(table_state)\n    return Table(\n        primary_key=\"id\",\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"components/table/#metanno.ui.Table--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>rows</code> <p>The data for each row in the table, where each row is a dictionary mapping column keys to their values.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>columns</code> <p>The columns to display in the table:</p> <ul> <li><code>key</code>: Unique identifier for the column.</li> <li><code>name</code>: Display name of the column.</li> <li><code>kind</code>: Type of data in the column (e.g., \"text\", \"hyperlink\", \"multi-text\", \"boolean\", ...).</li> <li><code>editable</code>: Whether the column is editable.</li> <li><code>filterable</code>: Whether the column can be filtered.</li> <li><code>choices</code>: Optional list of choices for the column (if applicable).</li> </ul> <p> TYPE: <code>ColumnData</code> </p> <code>primary_key</code> <p>The key used to uniquely identify each row in the table.</p> <p> TYPE: <code>str</code> </p> <code>filters</code> <p>The current filters applied to the table, mapping column keys to filter values.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>highlighted_rows</code> <p>List of row indices that should be highlighted.</p> <p> TYPE: <code>List[int]</code> </p> <code>handle</code> <p>Imperative handle for actions that can be performed on the table, such as scrolling:</p> <ul> <li><code>scroll_to_row_idx(row_idx: int)</code>: Scrolls the table to the specified row index.</li> <li><code>scroll_to_row_id(row_id: str)</code>: Scrolls the table to the specified row ID.</li> <li><code>focus()</code>: Sets focus on the currently open cell or full table if no cell is open.</li> </ul> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>auto_filter</code> <p>Whether to automatically apply filters as the user types.</p> <p> TYPE: <code>bool</code> </p> <code>input_value</code> <p>The current input value to show in the input field when the user is editing a cell. If undefined, this is automatically handled by the component.</p> <p> TYPE: <code>Union[str, Hyperlink]</code> </p> <code>suggestions</code> <p>List of suggestions to show when the user is typing in the input field.</p> <p> TYPE: <code>List[Any]</code> </p> <code>selection</code> <p>The current selection state of the table, including:</p> <ul> <li>row_id: Key of the row where the cursor is located.</li> <li>row_idx: Index of the row where the cursor is located.</li> <li>col: Key of the column where the cursor is located.</li> <li>mode: Mode of interaction, either \"EDIT\" or \"SELECT\".</li> <li>ranges: List of row ranges (rows mode), e.g. <code>[{\"row_idx\": 3}, ...]</code>.</li> </ul> <p> TYPE: <code>Optional[Selection]</code> </p> <code>multi_selection_mode</code> <p>Multi-selection behavior for the grid:</p> <ul> <li><code>False</code>: default cell selection behavior.</li> <li><code>\"rows\"</code>: multi-selection highlights full rows.</li> </ul> <p> TYPE: <code>Optional[Literal[False, 'rows']]</code> </p> <code>style</code> <p>Custom styles for the table component.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>A unique key for the component instance, used for React's reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_input_change</code> <p>Callback triggered when the input value changes in a cell:</p> <ul> <li><code>row_id</code>: Key of the row being edited.</li> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value entered by the user.</li> <li><code>cause</code>: Reason for the change (e.g., \"blur\", \"enter\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_scroll_bottom</code> <p>Callback triggered when the user scrolls to the bottom of the table:</p> <ul> <li><code>event</code>: Scroll event or a dictionary indicating if the user is at the bottom.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_cell_change</code> <p>Callback triggered when a cell's value changes:</p> <ul> <li><code>row_id</code>: Key of the row being edited.</li> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value of the cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_click_cell_content</code> <p>Callback triggered when the content of a cell is clicked (like a hyperlink):</p> <ul> <li><code>row_id</code>: Key of the row containing the clicked cell.</li> <li><code>row_idx</code>: Index of the row containing the clicked cell.</li> <li><code>name</code>: Key of the column containing the clicked cell.</li> <li><code>value</code>: Optional value of the clicked cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_filters_change</code> <p>Callback triggered when filters are updated:</p> <ul> <li><code>values</code>: Dictionary mapping column keys to filter values.</li> <li><code>column</code>: Key of the column being filtered.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_enter_row</code> <p>Callback triggered when the mouse enters a row:</p> <ul> <li><code>row_id</code>: Key of the row being hovered.</li> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_leave_row</code> <p>Callback triggered when the mouse leaves a row:</p> <ul> <li><code>row_id</code>: Key of the row being hovered.</li> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_hover_row</code> <p>Callback triggered when the mouse hovers over a row:</p> <ul> <li><code>row_id</code>: Key of the row being hovered, or <code>None</code> if not applicable.</li> <li><code>row_idx</code>: Index of the row being hovered, or <code>None</code> if not applicable.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_selection_change</code> <p>Callback triggered when the cursor selection changes:</p> <ul> <li><code>row_id</code>: Key of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>row_idx</code>: Index of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>name</code>: Key of the column where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>mode</code>: Interaction mode, either \"EDIT\" or \"SELECT\".</li> <li><code>cause</code>: Reason for the selection change (e.g., \"key\", \"blur\").</li> <li><code>ranges</code>: Selected ranges (rows mode), relative to the full table.</li> </ul> <p> TYPE: <code>Optional[Callable]</code> </p> <code>on_subset_change</code> <p>Callback triggered when the subset of visible rows changes:</p> <ul> <li><code>subset</code>: List of indices representing the new subset of rows.</li> </ul> <p> TYPE: <code>Callable</code> </p>"},{"location":"demos/","title":"Demos","text":"<p>Here are some examples of applications you can build with Metanno.</p> <p> Quaero Explorer</p><p>Explore and edit the Quaero dataset.</p>"},{"location":"demos/quaero-explorer/","title":"Quaero explorer","text":"<pre><code>from examples.quaero import app\n\n\napp(deduplicate=True)[0]\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Here is a list of tutorials to help you learn how to use Metanno.</p> <p>For a deeper understanding of the framework, check out the Pret tutorials.</p> <p>Notebook-first tutorials</p> <p>Most tutorials should have a \"Download notebook\" button at the top right : click it and drag the file to your favorite jupyterlab instance to experiment with the library yourself.</p> <p> Set up a new project</p><p>Learn how to install Metanno in a new project or add it to an existing one.</p><p> Run the Data Explorer demo</p><p>Run the Quaero Explorer demo app and discover the features of the DataWidgetFactory: persisting annotations, collaborating, and more.</p><p> Adding custom fields</p><p>Learn how to extend the data model and expose custom fields in table, text, and form widgets.</p><p> Pre-annotate Data with EDS-NLP</p><p>Use EDS-NLP to pre-annotate your data.</p><p> Nested and Linked Collections</p><p>Structure multi-level datasets with nested paths or linked collections.</p>"},{"location":"tutorials/new-project/","title":"Set up a new project","text":""},{"location":"tutorials/new-project/#set-up-a-new-project","title":"Set up a new project","text":"<p>Learn how to install Metanno in a brand\u2011new project or add it to an existing one.</p>"},{"location":"tutorials/new-project/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python &gt;= 3.7</li> <li>A clean environment (Conda/Mamba recommended).   On JupyterHub: use a conda/mamba environment (or micromamba). Avoid local environments like <code>venv</code> there to ensure JupyterLab picks up the front\u2011end code properly.</li> </ul> <p>Two ways to run Metanno</p> <ul> <li>Inside JupyterLab (great for notebooks and quick prototyping)</li> <li>Standalone app (run a local web server)</li> </ul>"},{"location":"tutorials/new-project/#create-or-reuse-a-project","title":"Create (or reuse) a project","text":"<p>You can manage your project dependencies with a pyproject.toml or a requirements.txt.</p> pyproject.tomlrequirements.txt <p>Below is a minimal example that starts from a dummy project and adds a dependency group for metanno:</p> <pre><code>[project]\nname = \"my-app\"\nversion = \"0.1.0\"\nrequires-python = \"&gt;=3.7\"\ndependencies = [\n\"edsnlp&gt;=0.17\",  # example base dependency\n]\n\n[dependency-groups]\nmetanno = [\n\"metanno&gt;=1.0.0-beta.6\",   # the annotation framework\n# add other dependencies as your annotation app grows\n]\n</code></pre> <p>Create and activate an environment, then (re-)install your project with the <code>metanno</code> group:</p> <pre><code>mamba create -n annotation python=3.11 -y\nmamba activate annotation\npip install . --group metanno\n</code></pre> <p>If you are adding to an existing project, just merge the <code>[dependency-groups]</code> section above and reinstall with <code>pip install . --group metanno</code></p> <p>If you don\u2019t want a pyproject.toml, create a requirements.txt:</p> <pre><code>metanno&gt;=1.0.0-beta.6\nedsnlp&gt;=0.20  # example additional dependency, not required at the moment\n</code></pre> <p>Then install in your environment:</p> <pre><code>mamba create -n annotation python=3.11 -y\nmamba activate annotation\npip install -r requirements.txt\n</code></pre>"},{"location":"tutorials/new-project/#use-in-jupyterlab","title":"Use in JupyterLab","text":"<ol> <li>If JupyterLab was already open, refresh the browser tab after installation.</li> <li>Create a new notebook</li> <li>Make sure you\u2019re using the Conda/Mamba environment where you installed Metanno.    To check, run the following in a new cell:    <pre><code>import sys\n\nprint(sys.executable)\n</code></pre>    It should show the path to the environment where you installed the app.    If it does, you can skip to the next step.    Otherwise, select the correct environment from the dropdown menu in the top\u2011right of the notebook.    If your environment does not appear, it means you have not yet \"linked\" it to JupyterLab.    Run the following command in the terminal:    <pre><code>mamba activate metanno\npip install ipykernel\npython -m ipykernel install --user --name metanno\n</code></pre></li> <li>Then run the following dummy app in a new cell:</li> </ol> <pre><code>from pret import component\nfrom pret_joy import Button\n\n\n@component\ndef SanityCheckApp():\n    return Button(\"Metanno is installed \u2705\", sx={\"m\": 1})\n\n\nSanityCheckApp()\n</code></pre> <p>If you see a clickable button appear below the cell, your JupyterLab setup is good to go.</p>"},{"location":"tutorials/new-project/#use-as-a-standalone-app","title":"Use as a standalone app","text":"<p>Create a file <code>app.py</code> with the same minimal app and run it locally. Ensure that you are in an environment where you can open ports (for instance port 5000 as in the example below), or contact your sysadmin.</p> <pre><code>from pret import run, component\nfrom pret_joy import Button\n\n\n@component\ndef SanityCheckApp():\n    return Button(\"Metanno is installed \u2705\", sx={\"m\": 1})\n\n\nif __name__ == \"__main__\":\n    run(SanityCheckApp(), port=5000)\n</code></pre> <p>Run the app:</p> <pre><code>python app.py\n</code></pre> <p>Your terminal will print a local URL. Open it in your browser and you should see the button displayed.</p>"},{"location":"reference/metanno/","title":"<code>metanno</code>","text":""},{"location":"reference/metanno/recipes/","title":"<code>metanno.recipes</code>","text":""},{"location":"reference/metanno/recipes/data_widget_factory/","title":"<code>metanno.recipes.data_widget_factory</code>","text":""},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.TextWidgetHandle","title":"<code>TextWidgetHandle</code>","text":"<p>           Bases: <code>TypedDict</code></p> <p>Imperative handle for interacting with a text annotation widget.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.TableWidgetHandle","title":"<code>TableWidgetHandle</code>","text":"<p>           Bases: <code>TypedDict</code></p> <p>Imperative handle for interacting with a table widget.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.FormWidgetHandle","title":"<code>FormWidgetHandle</code>","text":"<p>           Bases: <code>TypedDict</code></p> <p>Imperative handle for interacting with a form widget.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory","title":"<code>DataWidgetFactory</code>","text":"<p>The <code>DataWidgetFactory</code> is a helper widget factory for building interactive annotation and exploration applications using Metanno components. It manages data stores, shared state, and multiple synchronized views such as tables and annotated text views.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>data</code> <p>Initial dataset as a mapping from store keys to list-like records.</p> <p> TYPE: <code>Union[Dict[str, List[Dict[str, Any]]], Callable[[], Dict]]</code> </p> <code>sync</code> <p>Whether and how to sync and persist the data:</p> <ul> <li>False / None: no persistence (in-memory browser only).</li> <li>True: data will be synced between browser and server,   but not persisted on the server.</li> <li>str or PathLike: path where the store should be saved.   This we also enable syncing multiple notebook kernels or   server together.</li> </ul> <p> TYPE: <code>Union[bool, str, PathLike] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_selected_field_view","title":"<code>create_selected_field_view</code>","text":"<p>Render a single field from the currently selected row in a store.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_selected_field_view--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_key</code> <p>Key pointing to the collection to display.</p> <p> TYPE: <code>Any</code> </p> <code>shown_key</code> <p>Field key to show from the current row.</p> <p> TYPE: <code>Any</code> </p> <code>fallback</code> <p>Value returned when no row is available.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>Renderable</code> <p>Pret component instance displaying the selected field value.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_filters_view","title":"<code>create_filters_view</code>","text":"<p>Render filtering controls for a table linked to a store.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_filters_view--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_key</code> <p>Key pointing to the collection to filter.</p> <p> TYPE: <code>Any</code> </p> <code>fields</code> <p>Field metadata used for rendering filter inputs. Expects:</p> <ul> <li><code>key</code>: Field key.</li> <li><code>name</code>: Field display name.</li> <li> <p><code>kind</code>: Field data kind:</p> <ul> <li><code>\"text\"</code>: Plain text.</li> <li><code>\"boolean\"</code>: Boolean values.</li> <li><code>\"select\"/\"radio\"/\"autocomplete\"</code>: Multi choice selection.</li> </ul> </li> <li> <p><code>filterable</code>: If False, no filter control will be rendered.</p> </li> <li><code>options</code>: If present, a dropdown/autocomplete will be used     with the provided options (can also be a function that takes the     selected sample as input and returns options).</li> </ul> <p> TYPE: <code>Sequence[FieldSpec]</code> </p> <code>style</code> <p>Inline style overrides for the wrapping container.</p> <p> TYPE: <code>Dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>min_input_width</code> <p>Minimum width applied to each input control.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>all_label</code> <p>Label used to reset a filter (no filtering).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'All'</code> </p> <code>label_bold</code> <p>Whether to render labels in bold.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Renderable</code> <p>Pret component instance rendering the filter controls.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_table_widget","title":"<code>create_table_widget</code>","text":"<p>Create a <code>Table</code> widget bound to a store entry. Field metadata is inferred from the underlying data, with optional callbacks for selection changes, hover, and cell content clicks. An imperative handle can be exposed for scrolling and filtering.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_table_widget--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_key</code> <p>Key pointing to the list-like store to render.</p> <p> TYPE: <code>Any</code> </p> <code>primary_key</code> <p>Field name that uniquely identifies each row (primary key).</p> <p> TYPE: <code>str</code> </p> <code>fields</code> <p>Field metadata used for rendering and editing. Expects:</p> <ul> <li><code>key</code>: Field key.</li> <li><code>name</code>: Field display name.</li> <li> <p><code>kind</code>: Field data kind:</p> <ul> <li><code>\"text\"</code>: Plain text.</li> <li><code>\"boolean\"</code>: Boolean values.</li> <li><code>\"hyperlink\"</code>: Clickable hyperlink.</li> <li><code>\"select\"/\"radio\"/\"autocomplete\"</code>: Multi choice selection.</li> </ul> </li> <li> <p><code>options</code>: If present, a dropdown/autocomplete will be used     with the provided options (can also be a function that takes the     selected sample as input and returns options).</p> </li> <li><code>editable</code>: If True, cells in this column are editable.</li> <li><code>filterable</code>: If False, no filter control will be rendered.</li> </ul> <p> TYPE: <code>Sequence[FieldSpec]</code> </p> <code>style</code> <p>Inline style overrides applied to the table container.</p> <p> TYPE: <code>Dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>handle</code> <p>Imperative handle exposing helpers :</p> <ul> <li><code>scroll_to_row_id(row_id)</code>: Scroll to the row with the given primary key</li> <li><code>scroll_to_row_idx(row_idx)</code>: Scroll to the specified row index.</li> <li><code>set_filter(col, value)</code>: Apply a filter on the given column.</li> <li><code>get_filters()</code>: Retrieve the current filter mapping.</li> <li><code>clear_filters()</code>: Clear all active filters.</li> <li><code>set_highlighted(row_ids)</code>: Highlight the specified rows by their IDs.</li> <li><code>get_adjacent_row_id(current_row_id, delta)</code>: Retrieve the next/previous   row ID within the filtered view, wrapping around.</li> <li><code>get_adjacent_row_idx(current_row_idx, delta)</code>: Retrieve the next/previous   row index within the filtered view, wrapping around.</li> </ul> <p> TYPE: <code>RefType[TableWidgetHandle] | None</code> DEFAULT: <code>None</code> </p> <code>accept_related_filter_keys</code> <p>Controls whether this table accepts filters broadcast by other views. <code>True</code> accepts all incoming filters, <code>False</code> accepts none, and a sequence restricts accepted filter keys.</p> <p> TYPE: <code>bool | Sequence[str]</code> DEFAULT: <code>True</code> </p> <code>on_selection_change</code> <p>[Any, Optional[int], Optional[str], str, Any, Optional[List[Dict[str, int]]]], None</p> <p> TYPE: <code>Callable[</code> DEFAULT: <code>None</code> </p> <code>on_mouse_hover_row</code> <p>Called when the mouse hovers over a row.</p> <ul> <li><code>row_id</code>: Primary key for that row.</li> <li><code>row_idx</code>: Index of the row under the pointer.</li> <li><code>modkeys</code>: Pressed modifier keys during the hover.</li> </ul> <p> TYPE: <code>Callable[[Any, int, List[str]], None] | None</code> DEFAULT: <code>None</code> </p> <code>on_click_cell_content</code> <p>Called when hyperlink-like content inside a cell is clicked.</p> <ul> <li><code>row_id</code>: Primary key of the clicked row.</li> <li><code>row_idx</code>: Index of the clicked row.</li> <li><code>col</code>: Field key containing the clickable content.</li> <li><code>value</code>: Value associated with the clicked cell.</li> </ul> <p> TYPE: <code>Callable[[Any, int, str, Any], None] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Renderable</code> <p>A Pret component instance rendering the configured table.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_form_widget","title":"<code>create_form_widget</code>","text":"<p>Render a single record from a store as a classic form with text, select, and boolean inputs. The current row can be changed via the imperative handle to keep multiple widgets in sync. When multiple rows are selected in a linked table, fields show mixed values and edits are applied to every selected row.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_form_widget--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_key</code> <p>Key pointing to the collection to edit.</p> <p> TYPE: <code>Any</code> </p> <code>primary_key</code> <p>Field name that uniquely identifies each row (primary key).</p> <p> TYPE: <code>str</code> </p> <code>fields</code> <p>Field metadata used for rendering and editing:</p> <ul> <li><code>key</code>: Field key.</li> <li><code>name</code>: Field display name.</li> <li> <p><code>kind</code>: Field data kind:</p> <ul> <li><code>\"text\"</code>: single-line text input.</li> <li><code>\"select\"</code>: dropdown select input.</li> <li><code>\"autocomplete\"</code>: autocomplete text input.</li> <li><code>\"radio\"</code>: radio button group.</li> <li><code>\"boolean\"</code>: checkbox input.</li> </ul> </li> <li> <p><code>editable</code>: If False, the field will be read-only.</p> </li> <li><code>options</code>: If present, a dropdown/autocomplete/radio will be used.</li> </ul> <p> TYPE: <code>Sequence[FieldSpec]</code> </p> <code>style</code> <p>Inline style overrides for the wrapping container.</p> <p> TYPE: <code>Dict[str, Any] | None</code> DEFAULT: <code>{}</code> </p> <code>min_input_width</code> <p>Minimum width applied to each input control.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>add_navigation_buttons</code> <p>Whether to display previous/next navigation buttons.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>handle</code> <p>Imperative handle exposing helpers :</p> <ul> <li><code>set_row_idx(row_idx)</code>: Switch to the row with the given index.</li> <li><code>get_row_idx()</code>: Retrieve the currently active row index.</li> </ul> <p> TYPE: <code>RefType[FormWidgetHandle] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Renderable</code> <p>A Pret component instance rendering the editable form.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_text_widget","title":"<code>create_text_widget</code>","text":"<p>Build a text annotation widget that pairs a text store with a spans store. Provides toolbar buttons for creating spans, keyboard navigation between documents, and callbacks for hover and click events.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.DataWidgetFactory.create_text_widget--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_text_key</code> <p>Key pointing to the store containing documents.</p> <p> TYPE: <code>Any</code> </p> <code>store_spans_key</code> <p>Key pointing to the store containing span annotations. If <code>None</code>, an empty store is created and managed locally.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>text_key</code> <p>Field name holding the raw text to annotate.</p> <p> TYPE: <code>str</code> </p> <code>text_primary_key</code> <p>Field name that uniquely identifies each text document.</p> <p> TYPE: <code>str</code> </p> <code>spans_primary_key</code> <p>Field name that uniquely identifies each span.</p> <p> TYPE: <code>str</code> </p> <code>fields</code> <p>Field metadata for span fields, used in the inline editor.</p> <p> TYPE: <code>Sequence[FieldSpec]</code> </p> <code>begin_key</code> <p>Field name for span start offsets.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'begin'</code> </p> <code>end_key</code> <p>Field name for span end offsets.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'end'</code> </p> <code>style_key</code> <p>Field name for span styling configuration key.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'style'</code> </p> <code>label_key</code> <p>Field name for span display label.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'label'</code> </p> <code>label_formatter</code> <p>Optional function used to compute the rendered label text for each span. It receives the full span dictionary and should return a string.</p> <p>If left as None, the uppercased <code>label_key</code> field will be used.</p> <p> TYPE: <code>Callable[[Dict[str, Any]], str] | None</code> DEFAULT: <code>None</code> </p> <code>button_key</code> <p>Field name that annotation buttons will update.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'label'</code> </p> <code>labels</code> <p>Mapping of label name to styling config (e.g. color, shortcut).</p> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> DEFAULT: <code>{}</code> </p> <code>style</code> <p>Inline style overrides for the text widget wrapper and content panes.</p> <p> TYPE: <code>Dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>handle</code> <p>Imperative handle exposing helpers:</p> <ul> <li><code>scroll_to_span(span_id)</code>: Scroll to the specified span.</li> <li><code>set_doc_idx(doc_idx)</code>: Switch to the document with the given index.</li> <li><code>get_doc_idx()</code>: Retrieve the currently active document index.</li> <li><code>set_highlighted_spans(span_ids)</code>: Highlight the specified spans.</li> <li><code>set_selected_span(span_id)</code>: Set the currently selected span.</li> </ul> <p> TYPE: <code>RefType[TextWidgetHandle] | None</code> DEFAULT: <code>None</code> </p> <code>on_change_text_id</code> <p>Called when navigation changes the active document.</p> <ul> <li><code>doc_id</code>: Identifier of the newly active document.</li> </ul> <p> TYPE: <code>Callable[[Any], None] | None</code> DEFAULT: <code>None</code> </p> <code>on_add_span</code> <p>Called after new spans are created from the current selection.</p> <ul> <li><code>span_ids</code>: List of identifiers for the newly created spans.</li> </ul> <p> TYPE: <code>Callable[[List[str]], None] | None</code> DEFAULT: <code>None</code> </p> <code>on_hover_spans</code> <p>Called whenever spans are hovered.</p> <ul> <li><code>span_ids</code>: List of identifiers for the currently hovered spans.</li> <li><code>mod_keys</code>: Modifier keys pressed during the hover.</li> </ul> <p> TYPE: <code>Callable[[List[str], List[str]], None] | None</code> DEFAULT: <code>None</code> </p> <code>on_click_span</code> <p>Called when a span is clicked.</p> <ul> <li><code>span_id</code>: Identifier of the clicked span.</li> <li><code>mod_keys</code>: Modifier keys pressed during the click.</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tuple[Renderable, Renderable]</code> <p>A pair of Pret components: the toolbar widget and the text widget.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.use_awaitable_state","title":"<code>use_awaitable_state</code>","text":"<p>Like <code>use_state</code>, but the setter returns a Future/Coroutine that can be awaited to wait for the state to be applied and the component to re-render.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.infer_fields","title":"<code>infer_fields</code>","text":"<p>Infer Metanno field metadata from a list-like collection of row dicts.</p>"},{"location":"reference/metanno/recipes/data_widget_factory/#metanno.recipes.data_widget_factory.infer_fields--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>rows</code> <p>Input records used to infer available keys and value types.</p> <p> TYPE: <code>Sequence[Dict[str, Any]]</code> </p> <code>hidden_keys</code> <p>Keys to exclude from the resulting fields.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>visible_keys</code> <p>Explicit allow-list of keys to render. When set, only these keys are included, ordered by <code>visible_keys</code> unless <code>first_keys</code> is provided.</p> <p> TYPE: <code>Sequence[str] | None</code> DEFAULT: <code>None</code> </p> <code>id_keys</code> <p>Keys treated as identifiers, rendered as hyperlinks.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>editable_keys</code> <p>Keys marked as editable.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>categorical_keys</code> <p>Keys treated as categorical, with options inferred from values.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>categories</code> <p>Optional mapping of key to precomputed candidate values.</p> <p> TYPE: <code>Dict[str, Sequence[Any]] | None</code> DEFAULT: <code>None</code> </p> <code>first_keys</code> <p>Keys promoted to the front of the ordering. When <code>visible_keys</code> is provided, it reorders only those keys that are present.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>column_names</code> <p>Optional mapping of key to display label.</p> <p> TYPE: <code>Dict[str, str] | None</code> DEFAULT: <code>None</code> </p> <code>filterable_keys</code> <p>Key that can be filtered in a table view. If None, all keys are filterable.</p> <p> TYPE: <code>Sequence[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[FieldSpec]</code> <p>Field specifications compatible with Metanno widgets.</p>"},{"location":"reference/metanno/recipes/explorer/","title":"<code>metanno.recipes.explorer</code>","text":""},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.TextWidgetHandle","title":"<code>TextWidgetHandle</code>","text":"<p>           Bases: <code>TypedDict</code></p> <p>Imperative handle for interacting with a text annotation widget.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.TableWidgetHandle","title":"<code>TableWidgetHandle</code>","text":"<p>           Bases: <code>TypedDict</code></p> <p>Imperative handle for interacting with a table widget.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.FormWidgetHandle","title":"<code>FormWidgetHandle</code>","text":"<p>           Bases: <code>TypedDict</code></p> <p>Imperative handle for interacting with a form widget.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetExplorerWidgetFactory","title":"<code>DatasetExplorerWidgetFactory</code>","text":"<p>The <code>DatasetExplorerWidgetFactory</code> is a helper widget factories for building interactive annotation and exploration applications using Metanno components. It manages data stores, shared state, and multiple synchronized views such as tables and annotated text views.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetExplorerWidgetFactory--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>data</code> <p>Initial dataset as a mapping from store keys to list-like records.</p> <p> TYPE: <code>Dict[str, List[Dict[str, Any]]]</code> </p> <code>sync</code> <p>Whether and how to sync and persist the data:</p> <ul> <li>False / None: no persistence (in-memory browser only).</li> <li>True: data will be synced between browser and server,   but not persisted on the server.</li> <li>str or PathLike: path where the store should be saved.   This we also enable syncing multiple notebook kernels or   server together.</li> </ul> <p> TYPE: <code>Union[bool, str, PathLike] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetExplorerWidgetFactory.create_table_widget","title":"<code>create_table_widget</code>","text":"<p>Create a <code>Table</code> widget bound to a store entry. Column metadata is inferred from the underlying data, with optional callbacks for position changes, hover, and cell content clicks. An imperative handle can be exposed for scrolling and filtering.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetExplorerWidgetFactory.create_table_widget--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_key</code> <p>Key pointing to the list-like store to render.</p> <p> TYPE: <code>Any</code> </p> <code>primary_key</code> <p>Column name that uniquely identifies each row (primary key).</p> <p> TYPE: <code>str</code> </p> <code>hidden_keys</code> <p>Columns that should be omitted from the view (empty when omitted).</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>id_keys</code> <p>Columns rendered as hyperlinks instead of plain text.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>editable_keys</code> <p>Columns that support inline editing.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>categorical_keys</code> <p>Columns with a fixed set of options for filtering and editing.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>first_keys</code> <p>Columns forced to appear first in the table.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>style</code> <p>Inline style overrides applied to the table container.</p> <p> TYPE: <code>Dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>handle</code> <p>Imperative handle exposing helpers :</p> <ul> <li><code>scroll_to_row_id(row_id)</code>: Scroll to the row with the given primary key</li> <li><code>scroll_to_row_idx(row_idx)</code>: Scroll to the specified row index.</li> <li><code>set_filter(col, value)</code>: Apply a filter on the given column.</li> <li><code>get_filters()</code>: Retrieve the current filter mapping.</li> <li><code>clear_filters()</code>: Clear all active filters.</li> <li><code>set_highlighted(row_ids)</code>: Highlight the specified rows by their IDs.</li> </ul> <p> TYPE: <code>RefType[TableWidgetHandle] | None</code> DEFAULT: <code>None</code> </p> <code>on_position_change</code> <p>Called when focus moves inside the table.</p> <ul> <li><code>row_id</code>: Primary key of the focused row.</li> <li><code>row_idx</code>: Index of the focused row.</li> <li><code>col</code>: Column key receiving focus.</li> <li><code>mode</code>: Interaction mode, such as <code>\"EDIT\"</code> or <code>\"SELECT\"</code>.</li> <li><code>cause</code>: What triggered the move (e.g. <code>\"key\"</code>, <code>\"mouse\"</code>).</li> </ul> <p> TYPE: <code>Callable[[Any, int, str, str, Any], None] | None</code> DEFAULT: <code>None</code> </p> <code>on_mouse_hover_row</code> <p>Called when the mouse hovers over a row.</p> <ul> <li><code>row_id</code>: Primary key for that row.</li> <li><code>row_idx</code>: Index of the row under the pointer.</li> <li><code>modkeys</code>: Pressed modifier keys during the hover.</li> </ul> <p> TYPE: <code>Callable[[Any, int, List[str]], None] | None</code> DEFAULT: <code>None</code> </p> <code>on_click_cell_content</code> <p>Called when hyperlink-like content inside a cell is clicked.</p> <ul> <li><code>row_id</code>: Primary key of the clicked row.</li> <li><code>row_idx</code>: Index of the clicked row.</li> <li><code>col</code>: Column key containing the clickable content.</li> <li><code>value</code>: Value associated with the clicked cell.</li> </ul> <p> TYPE: <code>Callable[[Any, int, str, Any], None] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Renderable</code> <p>A Pret component instance rendering the configured table.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetExplorerWidgetFactory.create_form_widget","title":"<code>create_form_widget</code>","text":"<p>Render a single record from a store as a classic form with text, select, and boolean inputs. The current row can be changed via the imperative handle to keep multiple widgets in sync.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetExplorerWidgetFactory.create_form_widget--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_key</code> <p>Key pointing to the collection to edit.</p> <p> TYPE: <code>Any</code> </p> <code>primary_key</code> <p>Column name that uniquely identifies each row (primary key).</p> <p> TYPE: <code>str</code> </p> <code>hidden_keys</code> <p>Columns excluded from the form (empty when omitted).</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>editable_keys</code> <p>Columns that can be edited, while others render as read-only.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>categorical_keys</code> <p>Columns with enumerated options rendered as selects.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>first_keys</code> <p>Columns forced to appear first in the form layout.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>style</code> <p>Inline style overrides for the wrapping container.</p> <p> TYPE: <code>Dict[str, Any] | None</code> DEFAULT: <code>{}</code> </p> <code>min_input_width</code> <p>Minimum width applied to each input control.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>handle</code> <p>Imperative handle exposing helpers :</p> <ul> <li><code>set_row_id(row_id)</code>: Switch to the row with the given primary key.</li> <li><code>get_row_id()</code>: Retrieve the currently active row ID.</li> </ul> <p> TYPE: <code>RefType[FormWidgetHandle] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Renderable</code> <p>A Pret component instance rendering the editable form.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetExplorerWidgetFactory.create_text_widget","title":"<code>create_text_widget</code>","text":"<p>Build a text annotation widget that pairs a text store with a spans store. Provides toolbar buttons for creating spans, keyboard navigation between documents, and callbacks for hover and click events.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.DatasetExplorerWidgetFactory.create_text_widget--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>store_text_key</code> <p>Key pointing to the store containing documents.</p> <p> TYPE: <code>Any</code> </p> <code>store_spans_key</code> <p>Key pointing to the store containing span annotations. If <code>None</code>, an empty store is created and managed locally.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>text_key</code> <p>Field name holding the raw text to annotate.</p> <p> TYPE: <code>str</code> </p> <code>text_primary_key</code> <p>Field name that uniquely identifies each text document.</p> <p> TYPE: <code>str</code> </p> <code>spans_primary_key</code> <p>Field name that uniquely identifies each span.</p> <p> TYPE: <code>str</code> </p> <code>begin_key</code> <p>Field name for span start offsets.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'begin'</code> </p> <code>end_key</code> <p>Field name for span end offsets.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'end'</code> </p> <code>style_key</code> <p>Field name for span styling configuration key.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'style'</code> </p> <code>label_key</code> <p>Field name for span display label.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'label'</code> </p> <code>labels</code> <p>Mapping of label name to styling config (e.g. color, shortcut).</p> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> DEFAULT: <code>{}</code> </p> <code>style</code> <p>Inline style overrides for the wrapper and content panes.</p> <p> TYPE: <code>Dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>handle</code> <p>Imperative handle exposing helpers:</p> <ul> <li><code>scroll_to_span(span_id)</code>: Scroll to the specified span.</li> <li><code>set_doc_by_id(doc_id)</code>: Switch to the document with the given ID.</li> <li><code>get_doc_id()</code>: Retrieve the currently active document ID.</li> <li><code>set_highlighted_spans(span_ids)</code>: Highlight the specified spans.</li> </ul> <p> TYPE: <code>RefType[TextWidgetHandle] | None</code> DEFAULT: <code>None</code> </p> <code>on_change_text_id</code> <p>Called when navigation changes the active document.</p> <ul> <li><code>doc_id</code>: Identifier of the newly active document.</li> </ul> <p> TYPE: <code>Callable[[str], None] | None</code> DEFAULT: <code>None</code> </p> <code>on_hover_spans</code> <p>Called whenever spans are hovered.</p> <ul> <li><code>span_ids</code>: List of identifiers for the currently hovered spans.</li> <li><code>mod_keys</code>: Modifier keys pressed during the hover.</li> </ul> <p> TYPE: <code>Callable[[List[str], List[str], None] | None</code> DEFAULT: <code>None</code> </p> <code>on_click_span</code> <p>Called when a span is clicked.</p> <ul> <li><code>span_id</code>: Span dictionary representing the clicked annotation.</li> <li><code>mod_keys</code>: Modifier keys pressed during the click.</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Renderable</code> <p>A Pret component instance rendering the annotation interface.</p>"},{"location":"reference/metanno/recipes/explorer/#metanno.recipes.explorer.use_awaitable_state","title":"<code>use_awaitable_state</code>","text":"<p>Like <code>use_state</code>, but the setter returns a Future/Coroutine that can be awaited to wait for the state to be applied and the component to re-render.</p>"},{"location":"reference/metanno/ui/","title":"ui","text":""},{"location":"reference/metanno/ui/#metannoui","title":"<code>metanno.ui</code>","text":""},{"location":"reference/metanno/ui/#metanno.ui.AnnotatedImage","title":"<code>AnnotatedImage</code>","text":"<p>An interactive image viewer that supports drawing, selecting, and styling geometric shapes (polygons, rectangles, points...) as annotations.</p> <p>Under the hood, we use Konva to render the image and its annotations.</p>"},{"location":"reference/metanno/ui/#metanno.ui.AnnotatedImage--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom metanno import AnnotatedImage\nimport time\n\n# Reactive store holding the annotation list\nimg_state = create_store([\n    {\n        \"id\": \"1\",\n        \"type\": \"polygon\",\n        \"points\": [10, 10, 50, 20],\n        \"label\": \"OBJ\",\n        \"style\": \"primary\",\n    }\n])\n\n# Style preset referenced from the annotation above\nimg_annotation_styles = {\n    \"primary\": {\n        \"strokeColor\": \"red\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"rgba(255,0,0,0.5)\",\n        \"labelPosition\": \"center\",\n        \"align\": \"center\",\n        \"verticalAlign\": \"top\",\n    },\n    \"secondary\": {\n        \"strokeColor\": \"blue\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"#0000ff80\",\n        \"textColor\": \"white\",\n    }\n}\n\n@component\ndef MyImage():\n    tracked_state = use_store_snapshot(img_state)\n\n    @use_event_callback\n    def on_mouse_select(modkeys, shapes):\n        # Toggle 'mouseSelected' flag\n        for shp in shapes:\n            img_state.append({\n                \"id\": str(time.time()),\n                \"points\": shp[\"points\"],\n                \"label\": \"OBJ\",\n                \"style\": \"primary\",\n            })\n\n    @use_event_callback\n    def on_click(shape_idx, modkeys):\n        if shape_idx is None:\n            img_state.clear()\n        else:\n            old_style = img_state[shape_idx].get(\"style\", \"primary\")\n            new_style = \"secondary\" if old_style == \"primary\" else \"primary\"\n            img_state[shape_idx][\"style\"] = new_style\n\n    return AnnotatedImage(\n        image=\"https://picsum.photos/400/300\",\n        annotations=tracked_state,\n        annotation_styles=img_annotation_styles,\n        on_mouse_select=on_mouse_select,\n        on_click=on_click,\n    )\n\nMyImage()\n</code></pre>"},{"location":"reference/metanno/ui/#metanno.ui.AnnotatedImage--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>annotations</code> <p>List of annotation objects drawn on top of the image. Each annotation must contain the geometric <code>type</code> and <code>points</code> fields (defining the shape) plus optional metadata such as:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Human-readable text shown next to the shape.</li> <li><code>style</code>: Key that looks up visual properties in <code>annotation_styles</code>.</li> <li><code>selected</code> / <code>highlighted</code> / <code>mouseSelected</code>: Booleans used by the   component when rendering interaction state.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>annotation_styles</code> <p>Named style presets referenced by the <code>style</code> field of an annotation.  Each preset may define properties such as stroke color, fill color, opacity, font size, and label alignment, using the following properties:</p> <ul> <li><code>strokeColor</code> (str): Color of the shape's stroke (e.g. <code>\"#ff0000\"</code>).</li> <li><code>strokeWidth</code> (int): Width of the shape's stroke in pixels.</li> <li><code>fillColor</code> (str): Background color of the shape (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>opacity</code> (float): Opacity of the shape's fill (0.0 to 1.0).</li> <li><code>shape</code> (str): Shape type, e.g. <code>\"polygon\"</code>, <code>\"rectangle\"</code>, <code>\"circle\"</code>, etc.</li> <li><code>fontSize</code> (int): Font size for the label text.</li> <li><code>align</code> (\"left\" | \"center\" | \"right\"): Horizontal alignment of the label text.</li> <li><code>verticalAlign</code> (\"top\" | \"middle\" | \"bottom\"): Vertical alignment of the label text.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>image</code> <p>Source URL or base-64 data URI of the image to annotate.</p> <p> TYPE: <code>str</code> </p> <code>mouse_selection</code> <p>Temporary shapes being drawn by the user while the mouse button is held down.  Supplied back to <code>on_mouse_select</code> when the gesture ends.</p> <p> TYPE: <code>Any</code> </p> <code>style</code> <p>Inline CSS-compatible style overrides for the root element of the component.</p> <p> TYPE: <code>Any</code> </p> <code>handle</code> <p>Optional imperative handle that the parent may call (empty for now).</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>React key for stable reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click</code> <p>Invoked when the user clicks on an existing shape.</p> <ul> <li><code>shape_id</code>: Identifier of the clicked annotation</li> <li><code>modkeys</code>: List of pressed modifier keys (e.g. <code>[\"Shift\"]</code>)</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_key_press</code> <p>Invoked when the component has focus and the user presses a key.</p> <ul> <li><code>key</code>: The key name (<code>\"Escape\"</code>, <code>\"Delete\"</code> \u2026)</li> <li><code>modkeys</code>: Concurrently pressed modifier keys</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_mouse_enter_shape</code> <p>Hover callbacks fired when the mouse pointer enters or leaves a shape.</p> <p> TYPE: <code>Any</code> </p> <code>on_mouse_select</code> <p>Fired after the user completes a drag selection.</p> <ul> <li><code>modkeys</code>: Modifier keys pressed during selection</li> <li><code>shapes</code>: All shapes inside the lasso / rectangle</li> </ul> <p> TYPE: <code>Any</code> </p>"},{"location":"reference/metanno/ui/#metanno.ui.Table","title":"<code>Table</code>","text":"<p>A component for displaying a table with various features such as filtering, highlighting rows, and handling cell changes.</p>"},{"location":"reference/metanno/ui/#metanno.ui.Table--examples","title":"Examples","text":"<pre><code>from pret import component, create_store, use_store_snapshot, use_event_callback\nfrom metanno import Table\n\ntable_state = create_store([\n    {\"id\": \"1\", \"date\": \"2023-01-01\", \"text\": \"Sample text 1\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"2\", \"date\": \"2023-01-03\", \"text\": \"Sample text 2\", \"type\": \"OTHER\", \"labels\": [\"ready\", \"danger\"]},\n    {\"id\": \"3\", \"date\": \"2023-01-05\", \"text\": \"Sample text 3\", \"type\": \"ENT\", \"labels\": [\"blue\"]},\n    {\"id\": \"4\", \"date\": \"2023-01-07\", \"text\": \"Sample text 4\", \"type\": \"OTHER\", \"labels\": [\"bad\"]},\n    {\"id\": \"5\", \"date\": \"2023-01-09\", \"text\": \"Sample text 5\", \"type\": \"ENT\", \"labels\": []},\n    {\"id\": \"6\", \"date\": \"2023-01-11\", \"text\": \"Sample text 6\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"7\", \"date\": \"2023-01-13\", \"text\": \"Sample text 7\", \"type\": \"FOO\", \"labels\": [\"ready\"]},\n    {\"id\": \"8\", \"date\": \"2023-01-15\", \"text\": \"Sample text 8\", \"type\": \"FOO2\", \"labels\": [\"danger\"]},\n    {\"id\": \"9\", \"date\": \"2023-01-17\", \"text\": \"Sample text 9\", \"type\": \"FOO3\", \"labels\": [\"blue\"]},\n    {\"id\": \"10\", \"date\": \"2023-01-19\", \"text\": \"Sample text 10\", \"type\": \"ENT\", \"labels\": [\"bad\"]},\n    {\"id\": \"11\", \"date\": \"2023-01-21\", \"text\": \"Sample text 11\", \"type\": \"OTHER\", \"labels\": [\"custom\"]},\n    {\"id\": \"12\", \"date\": \"2023-01-23\", \"text\": \"Sample text 12\", \"type\": \"ENT\", \"labels\": [\"ready\"]},\n    {\"id\": \"13\", \"date\": \"2023-01-25\", \"text\": \"Sample text 13\", \"type\": \"OTHER\", \"labels\": [\"danger\"]},\n    {\"id\": \"14\", \"date\": \"2023-01-27\", \"text\": \"Sample text 14\", \"type\": \"FOO2\", \"labels\": [\"blue\"]},\n    {\"id\": \"15\", \"date\": \"2023-01-29\", \"text\": \"Sample text 15\", \"type\": \"FOO3\", \"labels\": [\"bad\"]},\n])\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"date\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True, \"editable\": True},\n    {\"key\": \"type\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\", \"STUFF\", \"FOO\", \"FOO2\", \"FOO3\"]},\n    {\"key\": \"labels\", \"kind\": \"multi-text\", \"name\": \"labels\", \"filterable\": True, \"editable\": True, \"choices\": [\"ready\", \"danger\", \"blue\", \"bad\", \"custom\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_id, row_idx, col, new_value):\n        table_state[row_idx][col] = new_value\n\n    view_state = use_store_snapshot(table_state)\n    return Table(\n        primary_key=\"id\",\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"reference/metanno/ui/#metanno.ui.Table--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>rows</code> <p>The data for each row in the table, where each row is a dictionary mapping column keys to their values.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>columns</code> <p>The columns to display in the table:</p> <ul> <li><code>key</code>: Unique identifier for the column.</li> <li><code>name</code>: Display name of the column.</li> <li><code>kind</code>: Type of data in the column (e.g., \"text\", \"hyperlink\", \"multi-text\", \"boolean\", ...).</li> <li><code>editable</code>: Whether the column is editable.</li> <li><code>filterable</code>: Whether the column can be filtered.</li> <li><code>choices</code>: Optional list of choices for the column (if applicable).</li> </ul> <p> TYPE: <code>ColumnData</code> </p> <code>primary_key</code> <p>The key used to uniquely identify each row in the table.</p> <p> TYPE: <code>str</code> </p> <code>filters</code> <p>The current filters applied to the table, mapping column keys to filter values.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>highlighted_rows</code> <p>List of row indices that should be highlighted.</p> <p> TYPE: <code>List[int]</code> </p> <code>handle</code> <p>Imperative handle for actions that can be performed on the table, such as scrolling:</p> <ul> <li><code>scroll_to_row_idx(row_idx: int)</code>: Scrolls the table to the specified row index.</li> <li><code>scroll_to_row_id(row_id: str)</code>: Scrolls the table to the specified row ID.</li> <li><code>focus()</code>: Sets focus on the currently open cell or full table if no cell is open.</li> </ul> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>auto_filter</code> <p>Whether to automatically apply filters as the user types.</p> <p> TYPE: <code>bool</code> </p> <code>input_value</code> <p>The current input value to show in the input field when the user is editing a cell. If undefined, this is automatically handled by the component.</p> <p> TYPE: <code>Union[str, Hyperlink]</code> </p> <code>suggestions</code> <p>List of suggestions to show when the user is typing in the input field.</p> <p> TYPE: <code>List[Any]</code> </p> <code>selection</code> <p>The current selection state of the table, including:</p> <ul> <li>row_id: Key of the row where the cursor is located.</li> <li>row_idx: Index of the row where the cursor is located.</li> <li>col: Key of the column where the cursor is located.</li> <li>mode: Mode of interaction, either \"EDIT\" or \"SELECT\".</li> <li>ranges: List of row ranges (rows mode), e.g. <code>[{\"row_idx\": 3}, ...]</code>.</li> </ul> <p> TYPE: <code>Optional[Selection]</code> </p> <code>multi_selection_mode</code> <p>Multi-selection behavior for the grid:</p> <ul> <li><code>False</code>: default cell selection behavior.</li> <li><code>\"rows\"</code>: multi-selection highlights full rows.</li> </ul> <p> TYPE: <code>Optional[Literal[False, 'rows']]</code> </p> <code>style</code> <p>Custom styles for the table component.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>A unique key for the component instance, used for React's reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_input_change</code> <p>Callback triggered when the input value changes in a cell:</p> <ul> <li><code>row_id</code>: Key of the row being edited.</li> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value entered by the user.</li> <li><code>cause</code>: Reason for the change (e.g., \"blur\", \"enter\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_scroll_bottom</code> <p>Callback triggered when the user scrolls to the bottom of the table:</p> <ul> <li><code>event</code>: Scroll event or a dictionary indicating if the user is at the bottom.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_cell_change</code> <p>Callback triggered when a cell's value changes:</p> <ul> <li><code>row_id</code>: Key of the row being edited.</li> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value of the cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_click_cell_content</code> <p>Callback triggered when the content of a cell is clicked (like a hyperlink):</p> <ul> <li><code>row_id</code>: Key of the row containing the clicked cell.</li> <li><code>row_idx</code>: Index of the row containing the clicked cell.</li> <li><code>name</code>: Key of the column containing the clicked cell.</li> <li><code>value</code>: Optional value of the clicked cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_filters_change</code> <p>Callback triggered when filters are updated:</p> <ul> <li><code>values</code>: Dictionary mapping column keys to filter values.</li> <li><code>column</code>: Key of the column being filtered.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_enter_row</code> <p>Callback triggered when the mouse enters a row:</p> <ul> <li><code>row_id</code>: Key of the row being hovered.</li> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_leave_row</code> <p>Callback triggered when the mouse leaves a row:</p> <ul> <li><code>row_id</code>: Key of the row being hovered.</li> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_hover_row</code> <p>Callback triggered when the mouse hovers over a row:</p> <ul> <li><code>row_id</code>: Key of the row being hovered, or <code>None</code> if not applicable.</li> <li><code>row_idx</code>: Index of the row being hovered, or <code>None</code> if not applicable.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_selection_change</code> <p>Callback triggered when the cursor selection changes:</p> <ul> <li><code>row_id</code>: Key of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>row_idx</code>: Index of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>name</code>: Key of the column where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>mode</code>: Interaction mode, either \"EDIT\" or \"SELECT\".</li> <li><code>cause</code>: Reason for the selection change (e.g., \"key\", \"blur\").</li> <li><code>ranges</code>: Selected ranges (rows mode), relative to the full table.</li> </ul> <p> TYPE: <code>Optional[Callable]</code> </p> <code>on_subset_change</code> <p>Callback triggered when the subset of visible rows changes:</p> <ul> <li><code>subset</code>: List of indices representing the new subset of rows.</li> </ul> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/metanno/ui/#metanno.ui.AnnotatedText","title":"<code>AnnotatedText</code>","text":"<p>The <code>AnnotatedText</code> is a rich text viewer that supports span-level annotations, nested token highlights, and various user event callbacks.</p>"},{"location":"reference/metanno/ui/#metanno.ui.AnnotatedText--examples","title":"Examples","text":"<pre><code>from pret import (\n    component,\n    create_store,\n    use_store_snapshot,\n    use_event_callback,\n    use_state,\n)\nfrom metanno import AnnotatedText\nfrom pret_joy import Button, Box\n\ntxt = (\n    \"Metanno brings annotation components to Pret\\n\"\n    \"to build tailored annotation tools.\"\n)\n\n# One span covering the word \u201cMetanno\u201d\nspans = create_store(\n    [\n        {\n            \"id\": f\"span-0-7\",\n            \"start\": 0,\n            \"end\": 7,\n            \"label\": \"OBJ\",\n            \"highlighted\": False,\n        }\n    ]\n)\n\ntxt_annotation_styles = create_store(\n    {\n        \"OBJ\": {\n            \"color\": \"red\",\n            \"shape\": \"underline\",\n        }\n    }\n)\n\n\n@component\ndef MyText():\n    tracked_spans = use_store_snapshot(spans)\n    tracked_styles = use_store_snapshot(txt_annotation_styles)\n\n    @use_event_callback\n    def handle_select(ranges, modkeys):\n        for sp in ranges:\n            spans.extend(\n                [\n                    {\n                        \"id\": f\"span-{sp['begin']}-{sp['end']}\",\n                        \"start\": sp[\"begin\"],\n                        \"end\": sp[\"end\"],\n                        \"label\": \"OBJ\",\n                    }\n                ]\n            )\n\n    def on_mouse_enter_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = True\n\n    def on_mouse_leave_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = False\n\n    def on_span_style_change():\n        old_style = txt_annotation_styles[\"OBJ\"][\"shape\"]\n        new_style = \"box\" if old_style == \"underline\" else \"underline\"\n        txt_annotation_styles[\"OBJ\"][\"shape\"] = new_style\n\n    return Box(\n        Button(\"Change style\", on_click=on_span_style_change),\n        Button(\"Remove annotations\", on_click=lambda: spans.clear()),\n        AnnotatedText(\n            text=txt,\n            spans=tracked_spans,\n            annotation_styles=tracked_styles,\n            label_formatter=lambda span: f\"{span['label']} ({span['end'] - span['start']} chars)\",\n            on_mouse_select=handle_select,\n            on_mouse_enter_span=on_mouse_enter_span,\n            on_mouse_leave_span=on_mouse_leave_span,\n            style={\"gridColumn\": \"1 / -1\"},\n            begin_key=\"start\",  # Custom field names\n        ),\n        sx={\n            \"p\": 1,\n            \"display\": \"grid\",\n            \"gridTemplateColumns\": \"repeat(2, auto)\",\n            \"gap\": 1,\n        },\n    )\n\n\nMyText()\n</code></pre>"},{"location":"reference/metanno/ui/#metanno.ui.AnnotatedText--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>text</code> <p>Raw text content shown in the viewer.</p> <p> TYPE: <code>str</code> </p> <code>spans</code> <p>Span-level annotations over <code>text</code>.  Each span must include:</p> <ul> <li><code>begin</code> (or the value of <code>begin_key</code>): Begin character offset (inclusive).</li> <li><code>end</code> (or the value of <code>end_key</code>): End character offset (exclusive).</li> </ul> <p>and may optionally include:</p> <ul> <li><code>id</code> (or the value of <code>primary_key</code>): Optional unique span identifier.</li> <li><code>label</code> (or the value of <code>label_key</code>): Category name displayed next to / above the span.</li> <li><code>style</code> (or the value of <code>style_key</code>): Key referencing <code>annotation_styles</code>.</li> <li><code>selected</code> (or the value of <code>selected_key</code>): styled as selected by the user.</li> <li><code>highlighted</code> (or the value of <code>label_key</code>): styled as highlighted by the user.</li> </ul> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>annotation_styles</code> <p>Named style presets that control span background color, border, label placement, etc. Each style may define properties such as:</p> <ul> <li><code>color</code> (str): Color of the span. Will be overridden by <code>backgroundColor</code> and <code>borderColor</code>.</li> <li><code>shape</code> (\"underline\" | \"box\"): Visual style of the span.</li> <li><code>backgroundColor</code> (str): Background color of the span (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>borderColor</code> (str): Border color of the span (e.g. <code>\"#000000\"</code>).</li> <li><code>autoNestingLayout</code> (bool): Whether to automatically nest overlapping spans, rather than rendering them on top of each other.</li> </ul> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> <code>mouse_selection</code> <p>Current mouse drag selection expressed as character\u2010offset ranges. Passed to <code>on_mouse_select</code> when the action completes.</p> <p> TYPE: <code>List[Dict[str, int]]</code> </p> <code>style</code> <p>CSS style overrides for the outer element.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>handle</code> <p>Imperative handle for actions that can be performed on the component:</p> <ul> <li><code>scroll_to_line(line_idx: int, behavior: \"smooth\" | \"instant\" | \"auto\")</code>: Scrolls to the given line index.</li> <li><code>scroll_to_span(span_id: str, behavior: \"smooth\" | \"instant\" | \"auto\")</code>: Scrolls to the given span.</li> <li><code>clear_current_mouse_selection()</code>: Clears the current mouse selection.</li> </ul> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>begin_key</code> <p>Name of the field in <code>spans</code> that contains the begin character offset.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'begin'</code> </p> <code>end_key</code> <p>Name of the field in <code>spans</code> that contains the end character offset.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'end'</code> </p> <code>primary_key</code> <p>Name of the field in <code>spans</code> that contains the unique span identifier.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'id'</code> </p> <code>label_key</code> <p>Name of the field in <code>spans</code> that contains the human-readable label.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'label'</code> </p> <code>label_formatter</code> <p>Optional function used to compute each displayed span label from the full span dictionary. When provided, its return value is shown instead of the uppercased value from <code>label_key</code>.</p> <p> TYPE: <code>Optional[Callable[[Dict[str, Any]], str]]</code> DEFAULT: <code>None</code> </p> <code>style_key</code> <p>Name of the field in <code>spans</code> that contains the style key. This key will be used to look up visual properties in <code>annotation_styles</code>. If no style field is provided for a span, the style key will default to <code>label</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'style'</code> </p> <code>highlighted_key</code> <p>Name of the field in <code>spans</code> that indicates whether the span is highlighted.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'highlighted'</code> </p> <code>on_click_span</code> <p>Called when the user clicks on a span.</p> <ul> <li><code>span_id</code>: Identifier of the clicked annotation</li> <li><code>modkeys</code>: Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_key_press</code> <p>Called when a key is pressed with focus inside the component.</p> <ul> <li><code>key</code>: Key name</li> <li><code>ranges</code>: Current selection ranges</li> <li><code>modkeys</code>: Modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[Dict[str, int]], List[str]], None]</code> </p> <code>on_mouse_enter_span</code> <p>Called when the mouse pointer enters a span.</p> <ul> <li><code>span_id</code>: Identifier of the span entered</li> <li><code>modkeys</code>: Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_leave_span</code> <p>Called when the mouse pointer leaves a span.</p> <ul> <li><code>span_id</code>: Identifier of the span left</li> <li><code>modkeys</code>: Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_hover_spans</code> <p>Triggered every time the set of hovered spans changes.</p> <ul> <li><code>span_ids</code>: List of currently hovered span identifiers</li> <li><code>modkeys</code>: Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[str], List[str]], None]</code> </p> <code>on_mouse_select</code> <p>Triggered when the user finishes selecting text with the mouse.</p> <ul> <li><code>ranges</code>: Final list of selected ranges</li> <li><code>modkeys</code>: Modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[Dict[str, int]], List[str]], None]</code> </p> <code>key</code> <p>React reconciliation key (not the same as the previous <code>_key</code> props), this should be used to uniquely identify the component instance if there are multiple instances next to each other.</p> <p> TYPE: <code>Union[str, int]</code> </p>"},{"location":"reference/metanno/version/","title":"<code>metanno.version</code>","text":""},{"location":"reference/pret/ui/metanno/","title":"<code>pret.ui.metanno</code>","text":"<p>Backward compatibility shim for the previous <code>pret.ui.metanno</code> import path.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Added <code>label_formatter</code> to <code>create_text_widget</code> to allow users to provide a function to customize the displayed label on top of text spans</li> <li>Added function-based <code>options</code> to let users dynamically choose options to display in the dropdown selectors (or radio)</li> <li>Minor fixes to the data widget explorer and quaero demo</li> </ul>"},{"location":"changelog/#v100-beta6-2025-02-26","title":"v1.0.0-beta.6 (2025-02-26)","text":"<p>New notebook-based tutorials : each tutorial can now be downloaded as a Jupyter notebook and run \"at home\".</p>"},{"location":"changelog/#new-datawidgetfactory","title":"New DataWidgetFactory !","text":"<ul> <li>The <code>DatasetExplorerApp</code> factory moved to <code>metanno/recipes/data_widget_factory.py</code> and is now <code>DataWidgetFactory</code></li> <li><code>create_table_widget</code> and <code>create_form_widget</code> now take fields built with <code>infer_fields</code> (makes them reusable, or you can provide fields directly)</li> <li><code>create_text_widget</code>:</li> <li>now returns a toolbar widget and a text widget as a tuple</li> <li>now supports fields for the span editor to customize the toolbar</li> <li>Optional helpers can replace custom wiring</li> <li><code>create_selected_field_view</code> for simple value display of selected table rows, for instance to show a note header</li> <li><code>create_filters_view</code> for table filters</li> <li>Automatic syncing between tables, forms, and text widgets (no more manual callbacks required)</li> <li>Nested data support, ie <code>notes: [{\"note_id\": ..., \"note_text\": ..., \"entities\": [{\"id\": ..., \"begin\": ...}], ...}]</code> can be seen in two views using store keys <code>notes</code> and <code>notes.entities</code></li> <li>New connection status bar to know if an app is connected, disconnected or offline.</li> </ul>"},{"location":"changelog/#new-pret-changes","title":"New Pret changes !","text":"<ul> <li>Transactions, connection status, store rollbacks, Jupyter \"Open in a new tab\" button, and more.</li> <li>Check out Pret's changelog for more info.</li> </ul>"},{"location":"changelog/#v100-beta5-2025-12-09","title":"v1.0.0-beta.5 (2025-12-09)","text":"<ul> <li>Table input suggestions are now more visible (with a blueish outline)</li> <li>Update <code>Table</code> props and events: use pkey instead of row_key. Imperative handle now exposes scroll_to_row_idx and scroll_to_row_id. All row callbacks now receive row_id first, followed by row_idx, column, etc., and row_id can be None when unset. Adjust your handlers and highlighted-row keys to match.</li> <li>Dataset explorer factory inputs (metanno/recipes/explorer.py):</li> <li>create_table_widget is keyword-only and uses the new Table API and handle (TableWidgetHandle with scroll/filter/highlight helpers). If you passed handlers, update them to the new signatures with row_id.</li> <li>New form widget: create_form_widget renders a single record with text, select, and boolean inputs.</li> <li>Text handle keys are renamed to set_doc_by_id, get_doc_id, scroll_to_span, set_highlighted_spans, and set_doc_by_id. New on_click_span callback added and hover callback now passes (span_ids, mod_keys).</li> <li>Added <code>begin_key</code>, <code>end_key</code>, <code>primary_key</code>, <code>style_key</code>, <code>label_key</code> and <code>highlighted_key</code> to allow the user to customize the provenance of these attributes in the <code>AnnotatedText</code> component span data.</li> <li> Breaking API change in <code>metanno.recipes.explorer</code>:</li> <li><code>create_table_widget</code>:<ul> <li><code>pkey_column</code> -&gt; <code>primary_key</code></li> <li><code>hidden_columns</code> -&gt; <code>hidden_keys</code></li> <li><code>id_columns</code> -&gt; <code>id_keys</code></li> <li><code>editable_columns</code> -&gt; <code>editable_keys</code></li> <li><code>categorical_columns</code> -&gt; <code>categorical_keys</code></li> <li><code>first_columns</code> -&gt; <code>first_keys</code></li> </ul> </li> <li><code>create_text_widget</code>:<ul> <li><code>text_pkey_column</code> -&gt; <code>text_primary_key</code></li> <li><code>spans_pkey_column</code> -&gt; <code>text_primary_key</code></li> <li>new <code>primary_key</code></li> <li>new <code>begin_key</code></li> <li>new <code>end_key</code></li> <li>new <code>style_key</code></li> <li>new <code>label_key</code></li> <li>new <code>highlighted_key</code></li> </ul> </li> <li>Minor documentation fixes.</li> </ul>"},{"location":"changelog/#v100-beta4-2025-11-26","title":"v1.0.0-beta.4 (2025-11-26)","text":"<ul> <li>Moved <code>pret.ui.metanno</code> to <code>metanno.ui</code> (accessible via <code>from metanno import ...</code>)</li> <li>Renamed <code>actions</code> props to <code>handle</code> and manage them like true refs (i.e., users should access its content via <code>handle.current.xxx</code>)</li> <li>Added <code>on_mouse_hover_spans</code> and <code>on_mouse_hover_row</code> props to <code>AnnotatedText</code> and <code>Table</code> components, which should offer a more reliable way to highlighted spans/rows on mouse hover</li> <li>Refactored the <code>explorer</code> recipe and <code>examples/quaero.py</code> example to use widgets instead of a complex/monolithic app</li> </ul>"},{"location":"changelog/#v100-beta3-2025-08-21","title":"v1.0.0-beta.3 (2025-08-21)","text":"<ul> <li>Fix AnnotatedText bug in text selection on desktop browsers</li> </ul>"},{"location":"changelog/#v100-beta2-2025-08-18","title":"v1.0.0-beta.2 (2025-08-18)","text":"<ul> <li>Improved visibility of highlighted spans and layout of boxes with mixed inset/outset nesting</li> <li>Improved autocompletion experience for table suggestion inputs</li> <li>Improved tokenization of text, now allowed to split around dashes (-).</li> <li>Added theoretical support for touch screens (lightly tested)</li> <li>Added tutorials<ul> <li>Setup</li> <li>Run the Quaero Explorer app</li> <li>Customize the explorer</li> </ul> </li> </ul>"},{"location":"changelog/#v100-beta1-2025-06-06","title":"v1.0.0-beta.1 (2025-06-06)","text":"<ul> <li>Complete refacto of the framework: the Python-JS synchronized app mechanisms have been moved to a new library: Pret !</li> <li>Text and Table components are now callable directly from python, along other components built around MUI Joy. This gives the user the ability to easily build simple apps, and iterate on the design step by step.</li> <li>Metanno now features new Image annotation component.</li> <li>The tests run in Python 3.7 - 3.10, using playwright in headless Firefox, Chrome and Webkit.</li> <li>Metanno now also has a nice interactive documentation !</li> </ul>"},{"location":"changelog/#metanno-v0","title":"Metanno v0","text":"<p>Metanno v0 is a JupyterLab extension for building custom annotation interfaces. It focuses on textual documents with structured entities and aims for modularity, customization, and interactivity. Core features include multi-line and nested span annotations, table-based relational annotations, multiple data types (hyperlinks, text, lists), and an immutable state that can be synchronized between the frontend and backend. The project compiles Python app classes to JavaScript using Transcrypt, enabling fast, browser-side execution while keeping Python code on the kernel side. To create an app, the user must modify one of the apps in recipes/*.py, and handle state management using a huge Redux-style reducer in <code>select_state</code>.</p> <p>Last items in the v0 changelog:</p> <ul> <li>Almost complete typescript conversion</li> <li>Added column filters</li> <li>Customizable undo/redo logic</li> <li>Editable span annotations from a table view</li> <li>Accessible return value of a Python call from front end (async calls)</li> </ul>"},{"location":"tutorials/custom-fields/","title":"Annotating custom fields","text":"Download notebook"},{"location":"tutorials/custom-fields/#annotating-custom-fields","title":"Annotating custom fields","text":"<p>In this tutorial, we explain how to add new fields an annotation app build with the data widget factory (demoed with the Quaero dataset in the previous tutorial):</p> <p>In the current Quaero example, entities are nested inside each note (<code>notes[i][\"entities\"]</code>). You control which attributes appear in the UI by:</p> <ol> <li>Extending the imported data structure.</li> <li>Listing these attributes in widget fields (<code>infer_fields(...)</code> or manual form fields).</li> </ol> <p>Check out the Table component documentation for more details about supported field types.</p>"},{"location":"tutorials/custom-fields/#load-the-data","title":"Load the data","text":"<p>For example, add a note-level <code>source</code> field and an entity-level <code>negation</code> field.</p> <pre><code> notes.append(\n     {\n         \"note_id\": str(doc._.note_id),\n         \"note_text\": doc.text,\n+        \"source\": \"quaero\",  # (1)!\n        \"note_kind\": \"interesting\" if idx % 2 == 0 else \"very interesting\",\n         \"seen\": False,\n         \"entities\": [\n             {\n                 \"id\": f\"#{uuid.uuid4()}\",\n                 \"text\": str(e),\n                 \"begin\": e.start_char,\n                 \"end\": e.end_char,\n                 \"label\": e.label_,\n                 \"concept\": e._.cui,\n+                \"negation\": False,  # (2)!\n            }\n             for e in sorted(doc.spans[\"entities\"])\n         ],\n     }\n )\n</code></pre> <ol> <li>You can set this from metadata, a file path, or an upstream pipeline.</li> <li>Replace with <code>e._.negation</code> if your EDS-NLP pipeline populates it (for example with <code>nlp.add_pipe(\"eds.negation\")</code>).</li> </ol>"},{"location":"tutorials/custom-fields/#show-these-fields","title":"Show these fields","text":"<p>Update renderers in the Build the views and define their interactions section to include these attributes. For booleans such as <code>negation</code>, Metanno infers a boolean field type and renders a checkbox/toggle editor.</p> <pre><code>- visible_keys=[\"note_id\", \"seen\", \"note_text\", \"note_kind\"],\n+ visible_keys=[\"note_id\", \"seen\", \"note_text\", \"note_kind\", \"source\"],\n...\n- editable_keys=[\"seen\", \"note_kind\"],\n+ editable_keys=[\"seen\", \"note_kind\", \"source\"],\n...\n+ categorical_keys=[\"note_kind\", \"source\"],\n</code></pre> <pre><code> fields=[\n     {\"key\": \"note_id\", \"kind\": \"text\"},\n     {\n         \"key\": \"note_kind\",\n         \"kind\": \"radio\",\n         \"editable\": True,\n         \"options\": [\"interesting\", \"very interesting\"],\n         \"filterable\": True,\n     },\n     {\"key\": \"seen\", \"kind\": \"boolean\", \"editable\": True},\n+    {\"key\": \"source\", \"kind\": \"text\", \"editable\": True},\n]\n</code></pre> <pre><code>- visible_keys=[\"id\", \"text\", \"label\", \"concept\"],\n+ visible_keys=[\"id\", \"text\", \"label\", \"concept\", \"negation\"],\n...\n- editable_keys=[\"label\", \"concept\"],\n+ editable_keys=[\"label\", \"concept\", \"negation\"],\n</code></pre> <pre><code>- visible_keys=[\"label\", \"concept\"],\n+ visible_keys=[\"label\", \"concept\", \"negation\"],\n...\n- editable_keys=[\"label\", \"concept\"],\n+ editable_keys=[\"label\", \"concept\", \"negation\"],\n</code></pre> <p>Dropdown input</p> <p>Add new keys to <code>categorical_keys</code> if they should use a dropdown editor/filter (for example <code>concept</code>, <code>label</code>, or a custom string category like <code>source</code>).</p>"},{"location":"tutorials/multi-collections/","title":"Nested and linked collections","text":"Download notebook"},{"location":"tutorials/multi-collections/#nested-and-linked-collections","title":"Nested and linked collections","text":"<p>This tutorial explains how to model multi-level data in Metanno and keep views synchronized. Two patterns are common:</p> <ol> <li>Nested collections (for example <code>stays[].notes[]</code>).</li> <li>Linked collections at different paths (for example <code>stays[]</code>, <code>notes[]</code> and <code>entities[]</code>).</li> </ol> <p>In both cases, DataWidgetFactory views are connected through shared keys and referenced with path strings such as <code>stay.notes</code> (or <code>stays.notes</code> when your top-level key is plural).</p> <p>Widgets read from a <code>store_key</code> path:</p> <ul> <li><code>stays</code> points to the top-level collection.</li> <li><code>stays.notes</code> points to nested notes.</li> <li><code>stays.evidences</code> points to another nested collection.</li> </ul> <p>When collections are not nested, synchronization still works if rows share linking keys:</p> <ul> <li><code>stays.notes</code> and <code>stays.entities</code> point to data nested in <code>stays</code>: this is \"nesting\"</li> <li><code>stays.evidences</code> and <code>stays.notes</code> are not nested, but they share some primary keys: this is \"linking\".     Every entity in <code>stays.entities</code> should have <code>note_id</code> so it can align with <code>notes</code>.</li> </ul>"},{"location":"tutorials/multi-collections/#show-nested-collections","title":"Show nested collections","text":"<p>Nested can be easily displayed by providing paths to the sub-collections.  Let's work with the following toy dataset, with entities and notes nested in stays.</p> <pre><code>def build_nested_data():\n    return {\n        \"stays\": [\n            {\n                \"stay_id\": \"S1\",\n                \"service\": \"oncology\",\n                \"notes\": [\n                    {\"note_id\": \"S1-N1\", \"note_text\": \"Mammographie le 12/06.\"},\n                    {\"note_id\": \"S1-N2\", \"note_text\": \"Consultation de suivi.\"},\n                ],\n                \"entities\": [\n                    {\n                        \"id\": \"S1-N1-E1\",\n                        \"note_id\": \"S1-N1\",\n                        \"begin\": 16,\n                        \"end\": 21,\n                        \"text\": \"12/06\",\n                        \"label\": \"date\",\n                        \"mammography\": True,\n                    }\n                ],\n            },\n            {\n                \"stay_id\": \"S2\",\n                \"service\": \"cardiology\",\n                \"notes\": [\n                    {\"note_id\": \"S2-N1\", \"note_text\": \"Cardio chez M. Dupont.\"},\n                ],\n                \"entities\": [\n                    {\n                        \"id\": \"S2-N1-E1\",\n                        \"note_id\": \"S2-N1\",\n                        \"begin\": 0,\n                        \"end\": 6,\n                        \"text\": \"Cardio\",\n                        \"label\": \"procedure\",\n                    }\n                ],\n            },\n        ]\n    }\n</code></pre> <p>We'll first import the widget factory.</p> <pre><code>from metanno.recipes.data_widget_factory import DataWidgetFactory, infer_fields\n\nfactory = DataWidgetFactory(\n    data=build_nested_data,\n    # sync=True/path, enable sync to sync the user edits with the kernel/server\n)\n</code></pre> <p>We'll create a table view to display stays, pointing at <code>stays</code> in our data collection</p> <pre><code>stays_view = factory.create_table_widget(\n    store_key=\"stays\",\n    primary_key=\"stay_id\",\n    fields=infer_fields(factory.data[\"stays\"], visible_keys=[\"stay_id\", \"service\"]),\n)\n</code></pre> <p>Then we'll add another table view to display notes. Note that these notes are \"conditional\" on stays: only the notes of the selected stay are shown</p> <pre><code>notes_view = factory.create_table_widget(\n    store_key=\"stays.notes\",\n    primary_key=\"note_id\",\n    fields=infer_fields(\n        [n for s in factory.data[\"stays\"] for n in s[\"notes\"]],\n        visible_keys=[\"note_id\", \"note_text\"],\n        id_keys=[\"note_id\"],\n    ),\n)\n</code></pre> <p>Then we'll add another table view to display entities. Note that these entities are \"conditional\" on stays: only the entities of the stay stay are shown. They will be auto-linked to notes as they contain <code>note_id</code> field which is the primary key of the <code>stays.notes</code> view (see above).</p> <pre><code>entities_view = factory.create_table_widget(\n    store_key=\"stays.entities\",\n    primary_key=\"id\",\n    fields=infer_fields(\n        [e for s in factory.data[\"stays\"] for e in s[\"entities\"]],\n        visible_keys=[\"id\", \"note_id\", \"label\", \"mammography\"],\n        id_keys=[\"id\"],\n        editable_keys=[\"label\", \"mammography\"],\n    ),\n)\n</code></pre> <p>We could stop here if we only wanted table views, but we'll add another view to display entities annotated on texts.  Note how:</p> <ul> <li>the location of the texts is the same as the one we provided earlier for the table view: <code>store_text_key=\"stays.notes\"</code></li> <li>the location of the entities is the same as the one we provided earlier for the table view: <code>store_spans_key=\"stays.entities\"</code></li> </ul> <pre><code>note_text_view, ent_toolbar = factory.create_text_widget(\n    store_text_key=\"stays.notes\",\n    store_spans_key=\"stays.entities\",\n    text_key=\"note_text\",\n    text_primary_key=\"note_id\",\n    spans_primary_key=\"id\",\n    fields=infer_fields(\n        [e for s in factory.data[\"stays\"] for e in s[\"entities\"]],\n        visible_keys=[\"label\", \"mammography\"],\n        editable_keys=[\"label\", \"mammography\"],\n    ),\n    labels={\n        \"date\": {\"name\": \"Date\", \"color\": \"lightblue\"},\n    },\n)\n</code></pre> <p>Finally, let's compose everything in a single view:</p> <pre><code>from pret.react import div\nfrom pret_joy import Box, Divider, Stack\nfrom pret_simple_dock import Layout, Panel\n\nlayout = div(\n    Layout(\n        Panel(stays_view, key=\"Stays\"),\n        Panel(notes_view, key=\"Notes\"),\n        Panel(entities_view, key=\"Entities\"),\n        Panel(Stack(Box(ent_toolbar, sx={\"m\": 1}), Divider(), note_text_view), key=\"Note Text\"),\n        default_config={\n            \"kind\": \"row\",\n            \"children\": [\n                {\"kind\": \"column\", \"children\": [\"Stays\", \"Notes\", \"Entities\"], \"size\": 50},\n                {\"tabs\": [\"Note Text\"], \"size\": 50},\n            ],\n        },\n    ),\n    style={\n        \"background\": \"var(--joy-palette-background-level2, #f0f0f0)\",\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n        \"minHeight\": \"500px\",\n        \"--sd-background-color\": \"transparent\",\n    },\n)\n</code></pre> <p>And display it:</p> <pre><code>layout\n</code></pre>"},{"location":"tutorials/multi-collections/#linked-collections-stored-separately","title":"Linked collections stored separately","text":"<p>If you prefer separate top-level arrays, keep explicit foreign keys.</p> <p>Note that this is the same data, just viewed as separate collections !</p> <pre><code>def build_split_data():\n    return {\n        \"stays\": [\n            {\"stay_id\": \"S1\", \"service\": \"oncology\"},\n            {\"stay_id\": \"S2\", \"service\": \"cardiology\"},\n        ],\n        \"notes\": [\n            {\"stay_id\": \"S1\", \"note_id\": \"S1-N1\", \"note_text\": \"Mammographie le 12/06.\"},\n            {\"stay_id\": \"S1\", \"note_id\": \"S1-N2\", \"note_text\": \"Consultation de suivi.\"},\n            {\"stay_id\": \"S2\", \"note_id\": \"S2-N1\", \"note_text\": \"Cardio chez M. Dupont.\"},\n        ],\n        \"entities\": [\n            {\n                \"stay_id\": \"S1\",\n                \"id\": \"S1-N1-E1\",\n                \"note_id\": \"S1-N1\",\n                \"begin\": 16,\n                \"end\": 21,\n                \"text\": \"12/06\",\n                \"label\": \"date\",\n                \"mammography\": True,\n            },\n            {\n                \"stay_id\": \"S2\",\n                \"id\": \"S2-N1-E1\",\n                \"note_id\": \"S2-N1\",\n                \"begin\": 0,\n                \"end\": 6,\n                \"text\": \"Cardio\",\n                \"label\": \"procedure\",\n            },\n        ],\n    }\n</code></pre> <p>Let's create a compose the views as we did before. The trick is now to refer to collections using their new path, and to add foreign keys to the tables: whenever a user clicks a view, Metanno will automatically decide which view's filters should be changed to reflect the new selection on dependent views.</p> <p>The code below also demonstrate how fields can be defined manually instead of using <code>infer_fields</code>.</p> <pre><code>from pret.react import div\nfrom pret_joy import Box, Divider, Stack\nfrom pret_simple_dock import Layout, Panel\n\nfrom metanno.recipes.data_widget_factory import DataWidgetFactory, infer_fields\n\nsplit_factory = DataWidgetFactory(\n    data=build_split_data,\n    # sync=True/path, enable sync to sync the user edits with the kernel/server\n)\n\nsplit_stays_view = split_factory.create_table_widget(\n    store_key=\"stays\",\n    primary_key=\"stay_id\",\n    fields=infer_fields(split_factory.data[\"stays\"], visible_keys=[\"stay_id\", \"service\"]),\n)\n\n# fmt: off\nsplit_notes_view = split_factory.create_table_widget(\n    store_key=\"notes\",\n    primary_key=\"note_id\",\n    # or we could use infer_fields\n    fields=[\n        {\"key\": \"note_id\", \"name\": \"note_id\", \"kind\": \"hyperlink\", \"editable\": False, \"filterable\": True, \"options\": None},\n        {\"key\": \"stay_id\", \"name\": \"stay_id\", \"kind\": \"text\", \"editable\": False, \"filterable\": True, \"options\": None},\n        {\"key\": \"note_text\", \"name\": \"note_text\", \"kind\": \"text\", \"editable\": False, \"filterable\": True, \"options\": None},\n    ],\n)\n# fmt: on\n\n# fmt: off\nsplit_entities_view = split_factory.create_table_widget(\n    store_key=\"entities\",\n    primary_key=\"id\",\n    # or we could use infer_fields\n    fields=[\n        {\"key\": \"id\", \"name\": \"id\", \"kind\": \"hyperlink\", \"editable\": False, \"filterable\": True, \"options\": None},\n        {\"key\": \"stay_id\", \"name\": \"stay_id\", \"kind\": \"text\", \"editable\": False, \"filterable\": True, \"options\": None},\n        {\"key\": \"note_id\", \"name\": \"note_id\", \"kind\": \"text\", \"editable\": False, \"filterable\": True, \"options\": None},\n        {\"key\": \"label\", \"name\": \"label\", \"kind\": \"text\", \"editable\": True, \"filterable\": True, \"options\": [\"date\", \"procedure\"]},\n        {\"key\": \"mammography\", \"name\": \"mammo\", \"kind\": \"boolean\", \"editable\": True, \"filterable\": True, \"options\": None},\n    ],\n)\n# fmt: on\n\n# fmt: off\nsplit_note_text_view, split_ent_toolbar = split_factory.create_text_widget(\n    store_text_key=\"notes\",\n    store_spans_key=\"entities\",\n    text_key=\"note_text\",\n    text_primary_key=\"note_id\",\n    spans_primary_key=\"id\",\n    fields=[\n        {\"key\": \"label\", \"name\": \"label\", \"kind\": \"text\", \"editable\": True, \"filterable\": True, \"options\": [\"date\", \"procedure\"]},\n        {\"key\": \"mammography\", \"name\": \"mammo\", \"kind\": \"boolean\", \"editable\": True, \"filterable\": True, \"options\": None},\n    ],\n    labels={\n        \"date\": {\"name\": \"Date\", \"color\": \"lightblue\"},\n    },\n)\n# fmt: on\n\nsplit_layout = div(\n    Layout(\n        Panel(split_stays_view, key=\"Stays\"),\n        Panel(split_notes_view, key=\"Notes\"),\n        Panel(split_entities_view, key=\"Entities\"),\n        Panel(\n            Stack(Box(split_ent_toolbar, sx={\"m\": 1}), Divider(), split_note_text_view),\n            key=\"Note Text\",\n        ),\n        default_config={\n            \"kind\": \"row\",\n            \"children\": [\n                {\"kind\": \"column\", \"children\": [\"Stays\", \"Notes\", \"Entities\"], \"size\": 50},\n                {\"tabs\": [\"Note Text\"], \"size\": 50},\n            ],\n        },\n    ),\n    style={\n        \"background\": \"var(--joy-palette-background-level2, #f0f0f0)\",\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n        \"minHeight\": \"500px\",\n        \"--sd-background-color\": \"transparent\",\n    },\n)\n</code></pre> <p>And display it:</p> <pre><code>split_layout\n</code></pre> <p>Note how, before anything is selected, all notes and all entities are displayed in the table views.</p>"},{"location":"tutorials/pre-annotation/","title":"Pre-annotate data with EDS-NLP","text":"Download notebook"},{"location":"tutorials/pre-annotation/#pre-annotate-data-with-eds-nlp","title":"Pre-annotate data with EDS-NLP","text":"<p>This tutorial shows how to pre-annotate date spans with EDS-NLP and add a boolean <code>mammography</code> flag when the date appears close to a mammography mention.</p> <p>The goal is to expose this flag in Metanno as a checkbox in the entities widgets.</p>"},{"location":"tutorials/pre-annotation/#build-a-contextual-date-pipeline","title":"Build a contextual date pipeline","text":"<p>Use <code>eds.dates</code> to detect dates, then <code>eds.contextual_matcher</code> to enrich each date with an assigned value when a mammography term appears in the local context.</p> <pre><code>import edsnlp\nimport edsnlp.pipes as eds\n\nnlp = edsnlp.blank(\"eds\")\n\nnlp.add_pipe(eds.sentences())\nnlp.add_pipe(eds.normalizer())\nnlp.add_pipe(eds.dates())\nnlp.add_pipe(\n    eds.contextual_matcher(\n        patterns=[\n            dict(\n                span_getter=\"dates\",\n                assign=[\n                    dict(\n                        name=\"mammography\",\n                        regex=\"(mammo-?graph)\",\n                        window=\"words[-10:10] &amp; sent\",\n                        reduce_mode=\"keep_first\",\n                    ),\n                ],\n                source=\"mammography\",\n            ),\n        ],\n        label=\"date\",\n    ),\n);\n</code></pre> <p>Run it on some data first to ensure it works:</p> <pre><code>texts = [\"Le patient a eu une mammographie le 12 juin. Aucune autre mammographie pr\u00e9vue.\"]\nnlp.pipe(texts).to_pandas(converter=\"ents\", span_attributes=[\"assigned\", \"date\"])\n</code></pre> note_id start end label lexical_variant span_type assigned date 0 None 36 43 date 12 juin ents {'mammography': 'mammographie'} ????-06-12 <p>Tip</p> <p>If you only want dates with nearby mammography context, set <code>required=True</code> in the <code>assign</code> block of <code>eds.contextual_matcher</code>.</p>"},{"location":"tutorials/pre-annotation/#apply-the-pipeline-to-some-data","title":"Apply the pipeline to some data","text":"<p>We'll assume you have a collection of documents you want to apply the pipeline too.</p> <p>The example below shows how to load parquet data. Visit EDS-NLP's Data API docs to learn about other formats.</p> <pre><code>import uuid\n\n\ndef build_data():\n    # Apply the pipeline\n    # data = edsnlp.data.read_parquet(path_to_parquet_dataset)\n    # or, if you don't have data yet, comment the above and run\n    data = edsnlp.data.from_iterable(\n        [{\"note_id\": f\"#{i}\", \"note_text\": t} for i, t in enumerate(texts)],\n        converter=\"omop\",\n    )\n    data = data.map_pipeline(nlp)\n\n    # And assemble your data in collections of dicts\n    notes = []\n    for idx, doc in enumerate(data):\n        note_entities = []\n\n        for e in doc.ents:  # or doc.spans[...] if this is where your entities are\n            if e.label_ != \"date\":\n                continue\n            assigned = e._.assigned or {}\n            note_entities.append(\n                {\n                    \"id\": f\"#{uuid.uuid4()}\",\n                    \"text\": str(e),\n                    \"begin\": e.start_char,\n                    \"end\": e.end_char,\n                    \"label\": \"date\",\n                    \"concept\": None,\n                    \"mammography\": bool(assigned.get(\"mammography\")),\n                }\n            )\n\n        notes.append(\n            {\n                \"note_id\": str(doc._.note_id),\n                \"note_text\": doc.text,\n                \"seen\": False,\n                \"entities\": note_entities,\n            }\n        )\n\n    return {\"notes\": notes}\n</code></pre>"},{"location":"tutorials/pre-annotation/#build-the-widgets-note-text-info-form","title":"Build the widgets (note text + info form)","text":"<p>Create a <code>DataWidgetFactory</code>, then build:</p> <ol> <li>A note text view with editable entity fields (including <code>mammography</code>).</li> <li>An info view similar to Quaero: note form (with navigation buttons) + selected entity info.</li> </ol> <pre><code>from pret_joy import Box, Divider, Stack\n\nfrom metanno.recipes.data_widget_factory import DataWidgetFactory, infer_fields\n\nfactory = DataWidgetFactory(\n    data=build_data,\n    # sync=True/path, enable sync to sync the user edits with the kernel/server\n)\n\nnote_text_view, ent_view = factory.create_text_widget(\n    store_text_key=\"notes\",\n    store_spans_key=\"notes.entities\",\n    text_key=\"note_text\",\n    text_primary_key=\"note_id\",\n    spans_primary_key=\"id\",\n    fields=infer_fields(\n        [e for n in factory.data[\"notes\"] for e in n[\"entities\"]],\n        visible_keys=[\"label\", \"mammography\"],\n        editable_keys=[\"label\", \"mammography\"],\n        categorical_keys=[\"label\"],\n    ),\n    labels={\n        \"date\": {\"name\": \"Date\", \"color\": \"lightblue\", \"shortcut\": \"d\"},\n    },\n)\n\nnote_form_view = factory.create_form_widget(\n    store_key=\"notes\",\n    primary_key=\"note_id\",\n    fields=[\n        {\"key\": \"note_id\", \"kind\": \"text\"},\n        {\"key\": \"seen\", \"kind\": \"boolean\", \"editable\": True},\n    ],\n    add_navigation_buttons=True,\n)\n\ninfo_view = Stack(Box(note_form_view, sx={\"m\": \"10px\"}), Divider(), Box(ent_view, sx={\"m\": \"10px\"}))\n</code></pre> <p><code>mammography</code> is inferred as a boolean field, so it is rendered as a checkbox/toggle editor.</p> <p>You can now either view these widgets separately, or arrange them in a single layout like we did in the Run the Quaero Explorer tutorial.</p> <pre><code>from pret.react import div\nfrom pret_simple_dock import Layout, Panel\n\nnote_header = factory.create_selected_field_view(\n    store_key=\"notes\",\n    shown_key=\"note_id\",\n    fallback=\"Note\",\n)\n\nlayout = div(\n    Layout(\n        Panel(note_text_view, key=\"Note Text\", header=note_header),\n        Panel(info_view, key=\"Info\"),\n        default_config={\n            \"kind\": \"row\",\n            \"children\": [\n                {\"tabs\": [\"Note Text\"], \"size\": 65},\n                {\"tabs\": [\"Info\"], \"size\": 35},\n            ],\n        },\n    ),\n    style={\n        \"background\": \"var(--joy-palette-background-level2, #f0f0f0)\",\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n        \"minHeight\": \"420px\",\n        \"--sd-background-color\": \"transparent\",\n    },\n)\n\nlayout\n</code></pre> <ol></ol>"},{"location":"tutorials/run-quaero-explorer/","title":"Run the Quaero Explorer","text":"Download notebook"},{"location":"tutorials/run-quaero-explorer/#run-the-quaero-explorer","title":"Run the Quaero Explorer","text":"<p>Run the Quaero Explorer demo app and discover Metanno\u2019s collaborative workflow: real\u2011time syncing, multi\u2011panel editing, and simple persistence.</p>"},{"location":"tutorials/run-quaero-explorer/#prerequisites","title":"Prerequisites","text":"<p>Reuse the same environment you prepared in the New project tutorial. You should already have a working Python environment with Pret, Metanno, and EDS\u2011NLP installed.</p> <p>The script downloads the Quaero FrenchMed dataset on first run, so an Internet access is required.</p> <p>Create a new file named <code>quaero.py</code> in your project and copy the contents from the official example https://github.com/percevalw/metanno/blob/main/examples/quaero.py.</p>"},{"location":"tutorials/run-quaero-explorer/#run-the-app","title":"Run the app","text":"<p>From a terminal. The server will start at http://localhost:5000.</p> <pre><code>python quaero.py --port 5000\n</code></pre> <p>Or in JupyterLab, run the following cell:</p> <pre><code>from quaero import app\n\nview, handles = app(save_path=True)\nview\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#code-breakdown","title":"Code breakdown","text":"<p>Below, we break down the script.</p>"},{"location":"tutorials/run-quaero-explorer/#1-load-the-data","title":"1) Load the data","text":"<p>We first fetch and extracts the dataset if it isn\u2019t already present, and read the BRAT standoff annotations using EDS-NLP.</p> <p>We then build a collection of <code>notes</code> containing <code>entities</code>.</p> <pre><code>import logging\nfrom pathlib import Path\n\nURL = \"https://quaerofrenchmed.limsi.fr/QUAERO_FrenchMed_brat.zip\"\nDOWNLOAD_DIR = Path(\"./downloaded\")\n\n\ndef download_quaero():\n\"\"\"\n    If the Quaero dataset is not already downloaded,\n    download the Quaero dataset from the official URL and extract it\n    in the QUAERO_FrenchMed_brat directory.\n    \"\"\"\n    import os\n    import tempfile\n    from zipfile import ZipFile\n\n    import requests\n\n    if os.path.exists(DOWNLOAD_DIR / \"QUAERO_FrenchMed\"):\n        logging.info(f\"Quaero dataset already exists in {DOWNLOAD_DIR / 'QUAERO_FrenchMed'}\")\n        return\n    logging.info(\"Downloading Quaero dataset...\")\n    response = requests.get(URL)\n    if response.status_code != 200:\n        raise RuntimeError(f\"Failed to download Quaero dataset: {response.status_code}\")\n    with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n        temp_file.write(response.content)\n        temp_file_path = temp_file.name\n    logging.info(f\"Extracting Quaero dataset in {DOWNLOAD_DIR}...\")\n    with ZipFile(temp_file_path, \"r\") as zip_ref:\n        zip_ref.extractall(DOWNLOAD_DIR)\n\n\ndef build_data():\n    import uuid\n\n    import edsnlp\n\n    download_quaero()\n    data = edsnlp.data.read_standoff(\n        DOWNLOAD_DIR / \"QUAERO_FrenchMed/corpus\",\n        span_setter=\"entities\",\n        notes_as_span_attribute=\"cui\",\n    )\n    notes = []\n    for idx, doc in enumerate(data):\n        notes.append(\n            {\n                \"note_id\": str(doc._.note_id),\n                \"note_text\": doc.text,\n                \"note_kind\": \"interesting\" if idx % 2 == 0 else \"very interesting\",\n                \"seen\": False,\n                \"entities\": [\n                    {\n                        \"id\": f\"#{uuid.uuid4()}\",\n                        \"text\": str(e),\n                        \"begin\": e.start_char,\n                        \"end\": e.end_char,\n                        \"label\": e.label_,\n                        \"concept\": e._.cui,\n                    }\n                    for e in sorted(doc.spans[\"entities\"])\n                ],\n            }\n        )\n    return {\"notes\": notes}\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#2-make-a-widget-factory","title":"2) Make a widget factory","text":"<p>Let's use the <code>DataWidgetFactory</code>: it's a helper class that we can use to quickly compose apps to view and annotate views of our data. Under the hood, it orchestrate Metanno components such as Table, AnnotatedText, form fields to keep views synchronized and automatically infer schema relationships from the data.</p> <p>We'll pass the <code>build_data</code> function (and not it's result), and a path to save the current state of the annotated data. If no serialized store exists already, the factory will run the function. Otherwise, it will load the app state from the store directly: this is why we pass a function.</p> <pre><code>from pret.hooks import RefType, use_ref\n\nfrom metanno.recipes.data_widget_factory import (\n    DataWidgetFactory,\n    FormWidgetHandle,\n    TableWidgetHandle,\n    TextWidgetHandle,\n    infer_fields,\n)\n\nfactory = DataWidgetFactory(\n    data=build_data,\n    sync=\"quaero_app_state.bin\",\n)\ndata = factory.data\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#3-configure-labels","title":"3) Configure labels","text":"<p>We compute a stable list of labels, assign a color for each, and auto\u2011pick a one\u2011letter keyboard shortcut per label.</p> <pre><code>PALETTE = [\n    \"rgb(255,200,206)\",\n    \"rgb(210,236,247)\",\n    \"rgb(211,242,206)\",\n    \"rgb(208,245,229)\",\n    \"rgb(208,210,249)\",\n    \"rgb(232,205,251)\",\n    \"rgb(253,203,241)\",\n    \"rgb(252,221,201)\",\n    \"rgb(249,243,203)\",\n    \"rgb(230,246,204)\",\n]\n\nall_labels = list(dict.fromkeys(e[\"label\"] for n in data[\"notes\"] for e in n[\"entities\"]))\nshortcuts = set()\nlabels_config = {}\nprint(\"Labels of the dataset:\")\nfor i, lab in enumerate(all_labels):\n    labels_config[lab] = {}\n    if i &lt; len(PALETTE):\n        labels_config[lab][\"color\"] = PALETTE[i]\n    letter = next((c for c in lab.lower() if c not in shortcuts), None)\n    if letter:\n        shortcuts.add(letter)\n        labels_config[lab][\"shortcut\"] = letter\n    print(\" -\", lab.ljust(5), \"-&gt;\", labels_config[lab])\n</code></pre> <pre><code>Labels of the dataset:\n - CHEM  -&gt; {'color': 'rgb(255,200,206)', 'shortcut': 'c'}\n - PROC  -&gt; {'color': 'rgb(210,236,247)', 'shortcut': 'p'}\n - LIVB  -&gt; {'color': 'rgb(211,242,206)', 'shortcut': 'l'}\n - DISO  -&gt; {'color': 'rgb(208,245,229)', 'shortcut': 'd'}\n - PHYS  -&gt; {'color': 'rgb(208,210,249)', 'shortcut': 'h'}\n - ANAT  -&gt; {'color': 'rgb(232,205,251)', 'shortcut': 'a'}\n - OBJC  -&gt; {'color': 'rgb(253,203,241)', 'shortcut': 'o'}\n - GEOG  -&gt; {'color': 'rgb(252,221,201)', 'shortcut': 'g'}\n - PHEN  -&gt; {'color': 'rgb(249,243,203)', 'shortcut': 'e'}\n - DEVI  -&gt; {'color': 'rgb(230,246,204)', 'shortcut': 'v'}\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#4-build-the-views-and-define-their-interactions","title":"4) Build the views and define their interactions","text":"<p>We define the views that will be rendered in the app. Each view is a component that displays a specific part of the data. For each view, we'll also create a \"handle\" to be able to control the widgets imperatively (e.g. change the filters, scroll to a line) if we want to.</p> <p>View the documents as a table:</p> <pre><code>def make_note_kind_options(note):\n    if \"EMEA\" in note[\"note_id\"]:\n        return [\"interesting\", \"very interesting\"]\n    else:\n        return []\n\nnotes_table_handle: RefType[TableWidgetHandle] = use_ref()\nnotes_view = factory.create_table_widget(\n    store_key=\"notes\",\n    primary_key=\"note_id\",\n    # Instead of using infer_fields, we can also define the\n    # fields manually which can actually be simpler\n    fields=[  # type: ignore\n        {\"key\": \"note_id\", \"name\": \"note_id\", \"kind\": \"text\", \"filterable\": True},\n        {\"key\": \"note_text\", \"name\": \"note_text\", \"kind\": \"text\", \"editable\": False, \"filterable\": True},  # noqa: E501\n        {\"key\": \"note_kind\", \"name\": \"note_kind\", \"kind\": \"text\", \"editable\": True, \"options\": make_note_kind_options, \"filterable\": True},  # noqa: E501\n        {\"key\": \"seen\", \"name\": \"seen\", \"kind\": \"boolean\", \"editable\": True, \"filterable\": True},  # noqa: E501\n    ],\n    style={\"--min-notebook-height\": \"300px\"},\n    handle=notes_table_handle,\n)\n</code></pre> <p>Show the selected note as a form:</p> <pre><code>note_form_handle: RefType[FormWidgetHandle] = use_ref()\nnote_form_view = factory.create_form_widget(\n    store_key=\"notes\",\n    primary_key=\"note_id\",\n    fields=[  # type: ignore\n        {\"key\": \"note_id\", \"kind\": \"text\"},\n        {\"key\": \"note_kind\", \"kind\": \"radio\", \"editable\": True, \"options\": make_note_kind_options, \"filterable\": True},  # noqa: E501\n        {\"key\": \"seen\", \"kind\": \"boolean\", \"editable\": True},\n    ],\n    add_navigation_buttons=True,\n    style={\"--min-notebook-height\": \"300px\", \"margin\": \"10px\"},\n    handle=note_form_handle,\n)\n# fmt: on\n</code></pre> <p>View the entities as a table:</p> <pre><code>ents_table_handle: RefType[TableWidgetHandle] = use_ref()\nentities_view = factory.create_table_widget(\n    store_key=\"notes.entities\",\n    primary_key=\"id\",\n    fields=infer_fields(\n        [e for n in data[\"notes\"] for e in n[\"entities\"]],\n        visible_keys=[\"id\", \"text\", \"label\", \"concept\"],\n        id_keys=[\"id\"],\n        editable_keys=[\"label\", \"concept\"],\n        categorical_keys=[\"label\", \"concept\"],\n    ),\n    style={\"--min-notebook-height\": \"300px\"},\n    handle=ents_table_handle,\n)\n</code></pre> <p>View and edit the note text with highlighted entities.  It returns both the text view and a view for the entity being edited</p> <pre><code>note_text_handle: RefType[TextWidgetHandle] = use_ref()\nnote_text_view, ent_view = factory.create_text_widget(\n    store_text_key=\"notes\",\n    # Where to look for spans data in the app data\n    store_spans_key=\"notes.entities\",\n    # Fields that will be displayed in the toolbar\n    fields=infer_fields(\n        [e for n in data[\"notes\"] for e in n[\"entities\"]],\n        visible_keys=[\"label\", \"concept\"],\n        editable_keys=[\"label\", \"concept\"],\n        categorical_keys=[\"label\", \"concept\"],\n    ),\n    text_key=\"note_text\",\n    text_primary_key=\"note_id\",\n    spans_primary_key=\"id\",\n    labels=labels_config,\n    style={\"--min-notebook-height\": \"300px\"},\n)\n</code></pre> <p>Finally, let's create a header for the note text panel, to be able to tell quickly which document we are viewing</p> <pre><code>note_header = factory.create_selected_field_view(\n    store_key=\"notes\",\n    shown_key=\"note_id\",\n    fallback=\"Note\",\n)\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#5-assemble-everything","title":"5) Assemble everything","text":"<p>Let's put everything in a panel layout (using the <code>pret-simple-dock</code> package).  Panels can be resized, rearranged (drag the tab handles), or hidden by docking into another panel\u2019s tab bar.</p> <pre><code>from pret.react import div\nfrom pret_joy import Box, Divider, Stack\nfrom pret_markdown import Markdown\nfrom pret_simple_dock import Layout, Panel\n\nlayout = Stack(\n    Layout(\n        div(Markdown(\"A markdown description of the dataset/task\"), style={\"margin\": \"10px\"}),\n        Panel(notes_view, key=\"Notes\"),\n        Panel(entities_view, key=\"Entities\"),\n        Panel(note_text_view, key=\"Note Text\", header=note_header),\n        Panel(Stack(note_form_view, Divider(), Box(ent_view, sx={\"m\": \"10px\"})), key=\"Info\"),\n        # Describe how the panels should be arranged by default\n        default_config={\n            \"kind\": \"row\",\n            \"children\": [\n                {\n                    \"kind\": \"column\",\n                    \"size\": 25,\n                    \"children\": [\n                        {\"tabs\": [\"Description\"], \"size\": 40},\n                        {\"tabs\": [\"Notes\"], \"size\": 30},\n                    ],\n                },\n                {\"tabs\": [\"Note Text\"], \"size\": 50},\n                {\n                    \"kind\": \"column\",\n                    \"size\": 25,\n                    \"children\": [\n                        {\"tabs\": [\"Info\"], \"size\": 65},\n                        {\"tabs\": [\"Entities\"], \"size\": 35},\n                    ],\n                },\n            ],\n        },\n        collapse_tabs_on_mobile=[\n            \"Note Text\",\n            \"Description\",\n            \"Notes\",\n            \"Note Form\",\n            \"Entities\",\n        ],\n    ),\n    factory.create_connection_status_bar(),\n    style={\n        \"background\": \"var(--joy-palette-background-level2, #f0f0f0)\",\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n        \"minHeight\": \"300px\",\n        \"--sd-background-color\": \"transparent\",\n    },\n)\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#6-render-or-serve","title":"6) Render or serve","text":"<p>You can either serve it or display it in a notebook. Check out the Notebook to App pret tutorial for more information. In the mean time, just display the <code>layout</code> var in a cell if you're in Jupyter, then right click it and click on \"\u269b\ufe0f Open in a new browser tab\" to create a dedicated tab to the app, or click \"Detach\" to put the app in its own JupyterLab panel.</p> <pre><code>layout\n</code></pre> <p>Offline app</p> <p>We defined our app as synced with a server file above when we instantiated the factory : since you are likely seing this in a github pages documentation, there is no server to sync to, or said otherwise, the server is currently unreachable. To avoid having users thinking their changes are saved, disconnected apps automatically rollback any changes made to a synchronized store.  This is the reason why you cannot edit the data of the above app. To \"unlock\" it in offline mode, comment \"sync=...\"</p> <p>You can interact programmatically with the app using the handles, for instance to change the currently displayed doc.</p> <pre><code>note_text_handle.current.set_doc_idx(20);\n</code></pre>"},{"location":"tutorials/run-quaero-explorer/#syncing-collaboration-and-saving","title":"Syncing, collaboration, and saving","text":"<p>Metanno (via Pret) can sync app state across clients and optionally persist it.</p>"},{"location":"tutorials/run-quaero-explorer/#live-sync-only-no-persistence","title":"Live sync only (no persistence)","text":"<p>Pass <code>sync=True</code> when creating the app to enable real\u2011time collaboration without saving to disk:</p> <pre><code>app = DataWidgetFactory(\n    data=build_data,\n    sync=True,\n)\n</code></pre> <p>Open the same notebook twice or the same app URL in two tabs: edits in one tab are mirrored to the other.</p>"},{"location":"tutorials/run-quaero-explorer/#live-sync-and-saving-to-a-file","title":"Live sync and saving to a file","text":"<p>As shown above, you can provide a file path to append every change to an on\u2011disk log:</p> <pre><code>app = DataWidgetFactory(\n    data=build_data,\n    sync=\"quaero_app_state.bin\",\n)\n</code></pre> <p>Changes are now saved on disk, and multiple servers/kernels can collaborate by pointing to the same file.</p>"},{"location":"tutorials/run-quaero-explorer/#what-is-the-saved-format","title":"What is the saved format?","text":"<p>It\u2019s a compact, binary, append\u2011only log of user mutations: you cannot read it directly.</p> <p>To inspect it, you can use <code>create_store</code> synced with the file and read current state, but the object will receive live updates as the underlying file changes, and you risk mutating it by accident.</p> <p>Prefer using the <code>load_store_snapshot</code> function to load the current state of the store as a pure Python object without subscribing to updates or risking modifying it:</p> <pre><code>from pret.store import load_store_snapshot\n\ndata = load_store_snapshot(\"quaero_app_state.bin\")\nprint(len(data[\"notes\"]), type(data[\"notes\"]))\n</code></pre> <pre><code>2536 &lt;class 'list'&gt;\n</code></pre> <p>To export to other formats, write a small exporter from your in\u2011memory data (<code>app.data</code>). We recommend using EDS\u2011NLP data connectors since it supports several data formats and schemas.</p>"}]}