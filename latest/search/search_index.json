{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#metanno","title":"Metanno","text":"<p>Metanno is a Python library aimed at building dynamic annotation interfaces customized to your needs without leaving your notebook.</p> <p>At the moment, Metanno focuses on textual documents with rich structured entities. Its main goals are:</p> <ul> <li>modularity: you decide how many views of your data are needed</li> <li>customization: you can easily customize the software behavior in Python and see the changes immediately</li> <li>interactivity: all of your annotations are immediately available as Python objects as soon as you edit something</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#annotate-anything","title":"Annotate anything","text":"<p>Metanno allows users to create a wide variety of annotations, including multiline and nested span annotations with text views, as well as document level, relational, or complex annotations with table views.</p> <p>It also supports multiple data types, including hyperlinks, text, and lists, and allows users to switch between text and table views for their annotations.</p>"},{"location":"#easy-setup","title":"Easy setup","text":"<p>Metanno is easy to install with a simple</p> <pre><code>pip install metanno\n</code></pre> <p>Unlike many other alternatives, when used in JupyterLab, it does not require users to open any ports or leave their notebook to launch a server. It also allows users to write their own apps in Python and while automatically benefiting from the speed of client run Javascript code with a React-based implementation.</p>"},{"location":"#interactive-and-customizable-by-design","title":"Interactive and customizable by design","text":"<ul> <li>visualize and edit the current app state directly in Python</li> <li>update the UI in Python, execute the cell and see the results immediately</li> <li>immutable state management, any state mutation is recorded and undoable</li> <li>many event handlers to react to any user action (click, hover, type, ...)</li> </ul> <p>Metanno is designed to be highly interactive and customizable, with the ability to visualize and edit app states directly in Python and update the UI in real time. It also offers a variety of event handlers that allow users to react to any user action. This makes it easy to create tailored and responsive apps UIs in JupyterLab.</p>"},{"location":"#why-another-annotation-tool","title":"Why another annotation tool ?","text":"<p>The choice of annotation software must be taken into account in the design of the annotation scheme. For example, it is challenging to annotate implicit/document-level entities in Brat or to annotate relations on multiple lines, and impossible to handle multiple documents at once. There are many annotation tools available (see Neves et al.), but most of them are either proprietary, poorly adapted to document or multi-document annotation, require a complex installation that is not compatible with existing remote work environments, or are difficult to customize. Finally, the standardization of annotation levels (mention / relation / event) is an obstacle to the development of new tasks. Given the limitations of the existing softwares and the difficulty to cover every need with a single static annotator, this project was initiated to provide a modular and fully customizable annotation framework, Metanno, and address these difficulties.</p>"},{"location":"#demo","title":"Demo","text":"<p>Below is a simple example of a Metanno app that allows users to annotate text spans and visualize the annotations in a table. Just select spans of text to annotate them. Hold the Shift (or Maj) while selecting to delete spans instead.</p> Show code <pre><code>from pret import component, proxy, use_tracked, use_event_callback\nfrom pret.ui.metanno import TextComponent\n\nstate = proxy([\n    {\"text\": \"soir\", \"begin\": 3, \"end\": 7, \"id\": \"s-3-7\", \"label\": \"ENT\"},\n    {\"text\": \"Charlie\", \"begin\": 59, \"end\": 66, \"id\": \"s-59-66\", \"label\": \"ENT\"},\n])\n\ntext = (\"Le soir, apr\u00e8s avoir mang\u00e9 sa soupe aux choux noy\u00e9e \"\n        \"d\u2019eau, Charlie allait toujours dans la chambre de ses \"\n        \"quatre grands-parents pour \u00e9couter leurs histoires, \"\n        \"et pour leur souhaiter bonne nuit.\\n\"\n        \"Chacun d\u2019eux avait plus de quatre-vingt-dix ans. Ils \"\n        \"\u00e9taient frip\u00e9s comme des pruneaux secs, ossus comme \"\n        \"des squelettes et, toute la journ\u00e9e, jusqu\u2019\u00e0 l\u2019apparition \"\n        \"de Charlie, ils se pelotonnaient dans leur lit, deux de \"\n        \"chaque c\u00f4t\u00e9, coiff\u00e9s de bonnets de nuit qui leur tenaient \"\n        \"chaud, passant le temps \u00e0 ne rien faire.\")\n\n\n@component\ndef App():\n    view_state = use_tracked(state)\n\n    @use_event_callback\n    def on_select(spans, mod_keys):\n        if \"Shift\" in mod_keys:\n            # Delete overlapped spans if the user holds Shift\n            state[:] = [\n                x\n                for x in state\n                if any((s['begin'] &gt;= x['end'] or s['end'] &lt;= x['begin']) for s in spans)\n            ]\n        else:\n            state.extend(\n                [{**s, \"id\": f\"s-{s['begin']}-{s['end']}\", \"text\": text[s['begin']:s['end']], \"label\": \"ENT\"} for s in spans]\n            )\n\n    return TextComponent(\n        text=text,\n        spans=view_state,\n        annotation_styles={\"ENT\": {\"color\": \"lightblue\"}},\n        on_mouse_select=on_select,\n    )\n\n\nApp()\n</code></pre> <p>Observe how the annotations are updated in the table below. The two views are synchronized because they share the same state (see the <code>state</code> variable in the code).</p> Show code <pre><code># \u2191 Complete the code above with the following snippet \u2191\nfrom pret import component, use_tracked, use_event_callback\nfrom pret.ui.metanno import TableComponent\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"begin\", \"kind\": \"text\", \"name\": \"begin\", \"filterable\": True},\n    {\"key\": \"end\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True},\n    {\"key\": \"label\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        view_state[row_idx][col] = new_value\n\n    for x in state:\n        x.setdefault(\"label\", \"ENT\")  # Ensure all rows have a label\n\n    view_state = use_tracked(state)\n    return TableComponent(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"first-app/","title":"Your first app","text":"<p>To begin, we are going to create a simple counter application that updates a small text everytime we click on a button. Create a new Jupyter notebook. JupyterLab is the preferred option since it allows panel-based layouts.</p>"},{"location":"first-app/#the-state","title":"The state","text":"<p>Every metanno app is controlled by a single state, with a JSON-like structure. The state contains all the information required to display the UI at a given time, and its structure is entirely up to you.</p> <p>To create a new state, execute the following code :</p> <pre><code>from metanno.state import State\n\nstate = State({\n    'counter': 0,\n})\n</code></pre> <p>You now have a state that is synchronized between the Python kernel and the client. Every modification made on either end is replicated on the other by sending small diffs over a websocket to keep everything in sync.</p>"},{"location":"first-app/#a-view","title":"A view","text":"<p>To interact with this state, we are going to create a new simple view consisting of a text and a button.</p> <pre><code>from metanno.view import View\n\nclass CounterView(View):\n    def increase_counter(self):\n        self.state[\"counter\"] += 1\n\n    def render(self, layout):\n        layout.text({\"text\": f\"The button was clicked {len(self.state['counter'])}\"})\n        layout.button({\"text\": \"Click me\", \"on_click\": self.increase_counter})\n\ndisplay(CounterView(state))\n</code></pre> <p>We create new views by inheriting from metanno <code>View</code> class. The state is linked to the view by passing it as an argument during the view instantiation. When displaying an instance of this class, its code is transpiled in Javascript, sent to the browser such that every method * will is executed in the browser directly to minimize latency.</p> <p>Every view must implement the render method, which takes a layout argument, used to display various UI elements in the view. The state we described above will also  be made available in every method of the View with the <code>self.state</code> attribute. This <code>render</code> method is called every time the state changes.</p> <p>In this case, we display a string containing the value of the counter defined above,  and a button that calls the transpiled Javascript version of the <code>increase_counter</code> method in the browser when clicked.</p> <p>Although it looks like it mutates the state directly, the state is actually proxied, meaning that we record the changes made on the state, produce a new state to replace the previous one, and send the changes to the kernel to update the Python state.</p>"},{"location":"first-app/#interactivity","title":"Interactivity","text":"<p>Click the button a few times and display the state of the app in another cell to observe the changes.</p> <pre><code>print(state)\n</code></pre> <p>The synchronization works both ways : execute the following code and observe the  changes in our view.</p> <pre><code>state[\"counter\"] += 100\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#as-a-user","title":"As a user","text":"<p>A simple pip installation should be enough to install Metanno both as a standalone web app framework and as a JupyterLab extension:</p> <pre><code>pip install metanno\n</code></pre> <p>However, depending on your Jupyter setup, especially for shared JupyterHub servers, a user-level installation might be necessary. In this case, run instead</p> <pre><code>pip install metanno --user\n</code></pre> <p>Refresh your JupyterLab page to load the installed javascript files, et voil\u00e0.</p>"},{"location":"installation/#as-a-contributor","title":"As a contributor","text":"<p>If you want to contribute to Metanno, you should have a programming environment:</p> <ul> <li>Python 3.7 or later, with pip and hatch installed</li> <li>Node.js 20 or later (you can use nvm to easily install and manage Node.js versions)</li> <li>JupyterLab 3 (the built extension will be compatible with JupyterLab 4)</li> <li>Various web browsers for testing (e.g., Chrome, Firefox, Safari)</li> <li>A Git client to clone the repository and manage your changes</li> </ul> <pre><code>git clone https://github.com/percevalw/metanno.git\n</code></pre> <p>Then, create a new branch for your changes:</p> <pre><code>git checkout -b my-feature-branch\n</code></pre> <p>Install the package in editable mode with development dependencies:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#running-the-tests","title":"Running the tests","text":"<p>Metanno uses playwright to test the JupyterLab extension (which should cover most of the app features). You can run the tests to ensure everything is working correctly.</p> <pre><code>hatch run tests\n</code></pre>"},{"location":"installation/#building-the-documentation","title":"Building the documentation","text":"<p>The documentation is built with MkDocs and MkDocs Material theme, along with quite a few customizations. To build the documentation, you can use the following command:</p> <pre><code>hatch run docs\n</code></pre>"},{"location":"state/","title":"State","text":"<p>Every metanno App is controlled by a single shared state, replicated between the Javascript client and the Python kernel.</p>"},{"location":"state/#immutability","title":"Immutability","text":"<p>To easily and efficiently detect which parts of the UI need to be updated, the state is immutable,  meaning that it cannot be changed directly. Instead, when the state needs to be  updated, a new copy of the state is created with the desired changes.  This new state is then passed to the UI, which can easily compare it to  the previous state and update only the parts that have changed.</p> <p>Additionally, state immutability makes it easy to implement undo and redo operations. This can be especially useful in applications where users may want to experiment with different changes and easily revert to a previous state if they are not satisfied with the results.</p>"},{"location":"state/#proxy","title":"Proxy","text":"<p>To mutate</p>"},{"location":"text-annotator/","title":"A text annotation widget","text":""},{"location":"views/","title":"Views","text":"<p>Views in Metanno are a way to organize the visual components of your application, such as buttons, text, and other widgets. They allow you to display different parts of your application state, and define how user interactions should affect that state.</p> <p>Your application can contain multiple views that are connected to a shared state, enabling them to interact and update the same data. These views can be organized within the JupyterLab layout system, allowing you to arrange and resize them in a flexible and customizable way. This makes it easy to create powerful and user-friendly annotation interfaces within Jupyter.</p>"},{"location":"views/#api","title":"API","text":"<p>Every view is structured along these lines.</p> <pre><code>from metanno.views import View\n\nclass CustomView(View):\n</code></pre> <p>We first define a new <code>CustomView</code> class that extends the <code>View</code> class from metanno. It is the base class for all views in Metanno and provides the necessary infrastructure for rendering the UI and interacting with the state.</p> <pre><code>    def render(self, layout):\n        layout.header({\"text\": \"My header\"})\n        layout.text({\"text\": f\"A counter : {len(self.state['spans'])}\"})\n        actions = layout.text_annotator({\n            \"text\": self.state['text'],\n            \"spans\": self.state['spans'],\n        })\n        layout.bottombar.button({\"text\": \"Button\", \"on_click\": self.on_click})\n        return actions\n</code></pre> <p>We then define the <code>render</code> method, which is responsible for rendering the view to the UI every time the state changes. It takes a layout object as an argument and uses it to add various components to the UI, such as a header, text, buttons, text / table annotation widgets. The render method also returns an actions dictionary containing some methods that you can call to programmatically interact with the widgets.</p> <pre><code>    def on_click(self):\n        # do something every time the button is clicked\n        # like mutating the state\n        ...\n</code></pre> <p>We then define the event handlers, such as the <code>on_click</code> method in this example, which is called every time the button in the view is clicked.  It can be used to mutate the state or trigger an action.</p>"},{"location":"bts/comms/","title":"Comms","text":""},{"location":"bts/immutability/","title":"Immutability","text":""},{"location":"bts/jupyter/","title":"Jupyter integration","text":""},{"location":"bts/overview/","title":"Overview","text":"<p>Metanno relies on multiple concepts and technologies :</p> <ul> <li>python to javascript transpilation</li> <li>kernel and client synchronization and RPC</li> <li>state immutability</li> <li>jupyter extension</li> </ul> <p>Here is an overview of the whole system:  </p>"},{"location":"bts/transpilation/","title":"Behind the scene","text":"<p>If your code ran solely in the kernel, each user action would require sending data (such as the name of the button clicked) to the kernel, running the event handler to change the state, and sending the updated state back to the client so that the user interface is refreshed.</p> <p>Instead, Metanno takes a shortcut that greatly improves the user experience: your code is executed directly in the browser. However, this leads to some challenges that need to be addressed: </p> <ul> <li>Running Python code in the browser</li> <li>Keeping the kernel-side state updated</li> <li>Functions that cannot be run in the browser (e.g. reading a file)</li> <li>Updating the state from the kernel</li> </ul>"},{"location":"components/","title":"Building Blocks of Metanno","text":"<p>This page provides an overview of the base components available in <code>metanno</code>.</p> Component Description TextComponent View and interact with a text with optional annotations. ImageComponent View and interact with an image with optional annotations. TableComponent View and interact with a table"},{"location":"components/image-component/","title":"ImageComponent","text":""},{"location":"components/image-component/#pret.ui.metanno.ImageComponent","title":"ImageComponent","text":"<p>An interactive image viewer that supports drawing, selecting, and styling geometric shapes (polygons, rectangles, points...) as annotations.</p> <p>Under the hood, we use Konva to render the image and its annotations.</p>"},{"location":"components/image-component/#pret.ui.metanno.ImageComponent--examples","title":"Examples","text":"<pre><code>from pret import component, proxy, use_tracked, use_event_callback\nfrom pret.ui.metanno import ImageComponent\nimport time\n\n# Reactive store holding the annotation list\nimg_state = proxy([\n    {\n        \"id\": \"1\",\n        \"type\": \"polygon\",\n        \"points\": [10, 10, 50, 20],\n        \"label\": \"OBJ\",\n        \"style\": \"primary\",\n    }\n])\n\n# Style preset referenced from the annotation above\nimg_annotation_styles = {\n    \"primary\": {\n        \"strokeColor\": \"red\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"rgba(255,0,0,0.5)\",\n        \"labelPosition\": \"center\",\n        \"align\": \"center\",\n        \"verticalAlign\": \"top\",\n    },\n    \"secondary\": {\n        \"strokeColor\": \"blue\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"#0000ff80\",\n        \"textColor\": \"white\",\n    }\n}\n\n@component\ndef MyImage():\n    tracked_state = use_tracked(img_state)\n\n    @use_event_callback\n    def on_mouse_select(modkeys, shapes):\n        # Toggle 'mouseSelected' flag\n        for shp in shapes:\n            img_state.append({\n                \"id\": str(time.time()),\n                \"points\": shp[\"points\"],\n                \"label\": \"OBJ\",\n                \"style\": \"primary\",\n            })\n\n    @use_event_callback\n    def on_click(shape_idx, modkeys):\n        if shape_idx is None:\n            img_state.clear()\n        else:\n            old_style = img_state[shape_idx].get(\"style\", \"primary\")\n            new_style = \"secondary\" if old_style == \"primary\" else \"primary\"\n            img_state[shape_idx][\"style\"] = new_style\n\n    return ImageComponent(\n        image=\"https://picsum.photos/400/300\",\n        annotations=tracked_state,\n        annotation_styles=img_annotation_styles,\n        on_mouse_select=on_mouse_select,\n        on_click=on_click,\n    )\n\nMyImage()\n</code></pre>"},{"location":"components/image-component/#pret.ui.metanno.ImageComponent--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>annotations</code> <p>List of annotation objects drawn on top of the image. Each annotation must contain the geometric <code>type</code> and <code>points</code> fields (defining the shape) plus optional metadata such as:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Human-readable text shown next to the shape.</li> <li><code>style</code>: Key that looks up visual properties in <code>annotation_styles</code>.</li> <li><code>selected</code> / <code>highlighted</code> / <code>mouseSelected</code>: Booleans used by the   component when rendering interaction state.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>annotation_styles</code> <p>Named style presets referenced by the <code>style</code> field of an annotation.  Each preset may define properties such as stroke color, fill color, opacity, font size, and label alignment, using the following properties:</p> <ul> <li><code>strokeColor</code> (str): Color of the shape's stroke (e.g. <code>\"#ff0000\"</code>).</li> <li><code>strokeWidth</code> (int): Width of the shape's stroke in pixels.</li> <li><code>fillColor</code> (str): Background color of the shape (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>opacity</code> (float): Opacity of the shape's fill (0.0 to 1.0).</li> <li><code>shape</code> (str): Shape type, e.g. <code>\"polygon\"</code>, <code>\"rectangle\"</code>, <code>\"circle\"</code>, etc.</li> <li><code>fontSize</code> (int): Font size for the label text.</li> <li><code>align</code> (\"left\" | \"center\" | \"right\"): Horizontal alignment of the label text.</li> <li><code>verticalAlign</code> (\"top\" | \"middle\" | \"bottom\"): Vertical alignment of the label text.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>image</code> <p>Source URL or base-64 data URI of the image to annotate.</p> <p> TYPE: <code>str</code> </p> <code>mouse_selection</code> <p>Temporary shapes being drawn by the user while the mouse button is held down.  Supplied back to <code>on_mouse_select</code> when the gesture ends.</p> <p> TYPE: <code>Any</code> </p> <code>style</code> <p>Inline CSS-compatible style overrides for the root element of the component.</p> <p> TYPE: <code>Any</code> </p> <code>actions</code> <p>Optional imperative handles (e.g. <code>actions[\"scroll_to_shape\"](idx)</code>) that the parent may call.  Reserved for future expansion.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>React key for stable reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click</code> <p>Invoked when the user clicks on an existing shape.</p> <ul> <li><code>shape_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 List of pressed modifier keys (e.g. <code>[\"Shift\"]</code>)</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_key_press</code> <p>Invoked when the component has focus and the user presses a key.</p> <ul> <li><code>key</code> \u2013 The key name (<code>\"Escape\"</code>, <code>\"Delete\"</code> \u2026)</li> <li><code>modkeys</code> \u2013 Concurrently pressed modifier keys</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_mouse_enter_shape</code> <p>Hover callbacks fired when the mouse pointer enters or leaves a shape.</p> <p> TYPE: <code>Any</code> </p> <code>on_mouse_select</code> <p>Fired after the user completes a drag selection.</p> <ul> <li><code>modkeys</code> \u2013 Modifier keys pressed during selection</li> <li><code>shapes</code> \u2013 All shapes inside the lasso / rectangle</li> </ul> <p> TYPE: <code>Any</code> </p>"},{"location":"components/table-component/","title":"TableComponent","text":""},{"location":"components/table-component/#pret.ui.metanno.TableComponent","title":"TableComponent","text":"<p>A component for displaying a table with various features such as filtering, highlighting rows, and handling cell changes.</p>"},{"location":"components/table-component/#pret.ui.metanno.TableComponent--examples","title":"Examples","text":"<pre><code>from pret import component, proxy, use_tracked, use_event_callback\nfrom pret.ui.metanno import TableComponent\n\ntable_state = proxy([\n    {\"id\": \"1\", \"date\": \"2023-01-01\", \"text\": \"Sample text 1\", \"label\": \"ENT\"},\n    {\"id\": \"2\", \"date\": \"2023-01-03\", \"text\": \"Sample text 2\", \"label\": \"OTHER\"},\n    {\"id\": \"3\", \"date\": \"2023-01-05\", \"text\": \"Sample text 3\", \"label\": \"ENT\"},\n    {\"id\": \"4\", \"date\": \"2023-01-07\", \"text\": \"Sample text 4\", \"label\": \"OTHER\"},\n    {\"id\": \"5\", \"date\": \"2023-01-09\", \"text\": \"Sample text 5\", \"label\": \"ENT\"},\n    {\"id\": \"6\", \"date\": \"2023-01-11\", \"text\": \"Sample text 6\", \"label\": \"OTHER\"},\n])\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"date\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True, \"editable\": True},\n    {\"key\": \"label\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        table_state[row_idx][col] = new_value\n\n    view_state = use_tracked(table_state)\n    return TableComponent(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"components/table-component/#pret.ui.metanno.TableComponent--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>columns</code> <p>The columns to display in the table:</p> <ul> <li><code>key</code>: Unique identifier for the column.</li> <li><code>name</code>: Display name of the column.</li> <li><code>kind</code>: Type of data in the column (e.g., \"text\", \"hyperlink\", \"multi-text\", \"boolean\", ...).</li> <li><code>editable</code>: Whether the column is editable.</li> <li><code>filterable</code>: Whether the column can be filtered.</li> <li><code>choices</code>: Optional list of choices for the column (if applicable).</li> </ul> <p> TYPE: <code>ColumnData</code> </p> <code>filters</code> <p>The current filters applied to the table, mapping column keys to filter values.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>highlighted_rows</code> <p>List of row indices that should be highlighted.</p> <p> TYPE: <code>List[int]</code> </p> <code>row_key</code> <p>The key used to uniquely identify each row in the table.</p> <p> TYPE: <code>str</code> </p> <code>rows</code> <p>The data for each row in the table, where each row is a dictionary mapping column keys to their values.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>actions</code> <p>Actions that can be performed on the table, such as scrolling.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>auto_filter</code> <p>Whether to automatically apply filters as the user types.</p> <p> TYPE: <code>bool</code> </p> <code>input_value</code> <p>The current input value to show in the input field when the user is editing a cell. If undefined, this is automatically handled by the component.</p> <p> TYPE: <code>Union[str, Hyperlink]</code> </p> <code>suggestions</code> <p>List of suggestions to show when the user is typing in the input field.</p> <p> TYPE: <code>List[Any]</code> </p> <code>position</code> <p>The current position of the cursor in the table, including:</p> <ul> <li>row_idx: Index of the row where the cursor is located.</li> <li>col: Key of the column where the cursor is located.</li> <li>mode: Mode of interaction, either \"EDIT\" or \"SELECT\".</li> </ul> <p> TYPE: <code>Position</code> </p> <code>style</code> <p>Custom styles for the table component.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>A unique key for the component instance, used for React's reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_input_change</code> <p>Callback triggered when the input value changes in a cell. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value entered by the user.</li> <li><code>cause</code>: Reason for the change (e.g., \"blur\", \"enter\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_scroll_bottom</code> <p>Callback triggered when the user scrolls to the bottom of the table. Will be called with the following parameters:</p> <ul> <li><code>event</code>: Scroll event or a dictionary indicating if the user is at the bottom.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_cell_change</code> <p>Callback triggered when a cell's value changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value of the cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_click_cell_content</code> <p>Callback triggered when the content of a cell is clicked (like a hyperlink). Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row containing the clicked cell.</li> <li><code>name</code>: Key of the column containing the clicked cell.</li> <li><code>value</code>: Optional value of the clicked cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_filters_change</code> <p>Callback triggered when filters are updated. Will be called with the following parameters:</p> <ul> <li><code>values</code>: Dictionary mapping column keys to filter values.</li> <li><code>column</code>: Key of the column being filtered.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_enter_row</code> <p>Callback triggered when the mouse enters a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_leave_row</code> <p>Callback triggered when the mouse leaves a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_position_change</code> <p>Callback triggered when the cursor position changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>name</code>: Key of the column where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>mode</code>: Interaction mode, either \"EDIT\" or \"SELECT\".</li> <li><code>cause</code>: Reason for the position change (e.g., \"key\", \"blur\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_subset_change</code> <p>Callback triggered when the subset of visible rows changes. Will be called with the following parameters:</p> <ul> <li><code>subset</code>: List of indices representing the new subset of rows.</li> </ul> <p> TYPE: <code>Callable</code> </p>"},{"location":"components/text-component/","title":"TextComponent","text":""},{"location":"components/text-component/#pret.ui.metanno.TextComponent","title":"TextComponent","text":"<p>The <code>TextComponent</code> is a rich text viewer that supports span-level annotations, nested token highlights, and various user event callbacks.</p>"},{"location":"components/text-component/#pret.ui.metanno.TextComponent--examples","title":"Examples","text":"<pre><code>from pret import component, proxy, use_tracked, use_event_callback, use_state\nfrom pret.ui.metanno import TextComponent\nfrom pret.ui.joy import Button, Box\n\ntxt = (\n    \"Metanno brings annotation components to Pret\\n\"\n    \"to build tailored annotation tools.\"\n)\n\n# One span covering the word \u201cMetanno\u201d\nspans = proxy([{\n    \"id\": f\"span-0-7\",\n    \"begin\": 0,\n    \"end\": 7,\n    \"label\": \"OBJ\",\n    \"highlighted\": False,\n}])\n\ntxt_annotation_styles = proxy({\n    \"OBJ\": {\n        \"color\": \"red\",\n        \"shape\": \"underline\",\n    }\n})\n\n@component\ndef MyText():\n    tracked_spans = use_tracked(spans)\n    tracked_styles = use_tracked(txt_annotation_styles)\n\n    @use_event_callback\n    def handle_select(ranges, modkeys):\n        for sp in ranges:\n            spans.extend([\n                {\n                    \"id\": f\"span-{sp['begin']}-{sp['end']}\",\n                    \"begin\": sp[\"begin\"],\n                    \"end\": sp[\"end\"],\n                    \"label\": \"OBJ\",\n                }\n            ])\n\n    def on_mouse_enter_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = True\n\n    def on_mouse_leave_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = False\n\n    def on_span_style_change():\n        old_style = txt_annotation_styles[\"OBJ\"][\"shape\"]\n        new_style = \"box\" if old_style == \"underline\" else \"underline\"\n        txt_annotation_styles[\"OBJ\"][\"shape\"] = new_style\n\n    return Box(\n        Button(\"Change style\", on_click=on_span_style_change),\n        Button(\"Remove annotations\", on_click=lambda: spans.clear()),\n        TextComponent(\n            text=txt,\n            spans=tracked_spans,\n            annotation_styles=tracked_styles,\n            on_mouse_select=handle_select,\n            on_mouse_enter_span=on_mouse_enter_span,\n            on_mouse_leave_span=on_mouse_leave_span,\n            style={\"gridColumn\": \"1 / -1\"},\n        ),\n        sx={\"p\": 1, \"display\": \"grid\", \"gridTemplateColumns\": \"repeat(2, auto)\", \"gap\": 1},\n    )\n\nMyText()\n</code></pre>"},{"location":"components/text-component/#pret.ui.metanno.TextComponent--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>text</code> <p>Raw text content shown in the viewer.</p> <p> TYPE: <code>str</code> </p> <code>spans</code> <p>Span-level annotations over <code>text</code>.  Each span must include <code>begin</code> and <code>end</code> character offsets, with optional fields:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Category name displayed next to / above the span.</li> <li><code>style</code>: Key referencing <code>annotation_styles</code>.</li> <li><code>selected</code> (bool): styled as selected by the user.</li> <li><code>highlighted</code> (bool): styled as highlighted by the user.</li> </ul> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>annotation_styles</code> <p>Named style presets that control span background color, border, label placement, etc. Each style may define properties such as:</p> <ul> <li><code>color</code> (str): Color of the span. Will be overridden by <code>backgroundColor</code> and <code>borderColor</code>.</li> <li><code>shape</code> (\"underline\" | \"box\"): Visual style of the span.</li> <li><code>backgroundColor</code> (str): Background color of the span (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>borderColor</code> (str): Border color of the span (e.g. <code>\"#000000\"</code>).</li> <li><code>autoNestingLayout</code> (bool): Whether to automatically nest overlapping spans, rather than rendering them on top of each other.</li> </ul> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> <code>mouse_selection</code> <p>Current mouse drag selection expressed as character\u2010offset ranges. Passed to <code>on_mouse_select</code> when the action completes.</p> <p> TYPE: <code>List[Dict[str, int]]</code> </p> <code>style</code> <p>CSS style overrides for the outer element.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>actions</code> <p>Optional imperative helpers (<code>scroll_to_span</code> \u2026, <code>clear_current_mouse_selection</code>).</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>React reconciliation key.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click_span</code> <p>Called when the user clicks on a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_key_press</code> <p>Called when a key is pressed with focus inside the component.</p> <ul> <li><code>key</code> \u2013 Key name</li> <li><code>ranges</code> \u2013 Current selection ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[Dict[str, int]], List[str]], None]</code> </p> <code>on_mouse_enter_span</code> <p>Hover callbacks when entering or leaving a span.</p> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_select</code> <p>Triggered when the user finishes selecting text with the mouse.</p> <ul> <li><code>ranges</code> \u2013 Final list of selected ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[Dict[str, int]], List[str]], None]</code> </p>"},{"location":"reference/metanno/","title":"<code>metanno</code>","text":""},{"location":"reference/metanno/connectors/","title":"<code>metanno.connectors</code>","text":""},{"location":"reference/metanno/connectors/brat/","title":"<code>metanno.connectors.brat</code>","text":""},{"location":"reference/metanno/connectors/brat/#metanno.connectors.brat.BratDataConnector","title":"<code>BratDataConnector</code>","text":"<p>Bidirectional connector with Brat. Allows nested directories (just set <code>path</code> to the top level directory) For now, writing events is not supported and any entity containing multiple fragments will only load the last one.</p>"},{"location":"reference/metanno/connectors/brat/#metanno.connectors.brat.BratDataConnector--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <code>merge_newline_fragments</code> <p>Merge fragments of a entity that was split by brat because it overlapped an end of line</p> <p> DEFAULT: <code>True</code> </p> <code>overwrite_txt</code> <p>Allow the connector to overwrite any .txt under <code>path</code></p> <p> DEFAULT: <code>False</code> </p> <code>overwrite_ann</code> <p>Allow the connector to overwrite any .txt under <code>path</code></p> <p> DEFAULT: <code>False</code> </p>"},{"location":"reference/metanno/connectors/pandas/","title":"<code>metanno.connectors.pandas</code>","text":""},{"location":"reference/metanno/connectors/pandas/#metanno.connectors.pandas.IO","title":"<code>IO</code>","text":"<p>Class to handle IO depending on the provided file type</p>"},{"location":"reference/metanno/connectors/pandas/#metanno.connectors.pandas.PandasDataConnector","title":"<code>PandasDataConnector</code>","text":"<p>Bidirectional connector with a Pandas DataFrame. No support for relations for now. Data will be fetched in the <code>path</code> folder, by looking at <code>txt.[file_type]</code> and/or <code>ann.[file_type]</code> files. Your setup should fall in one f the 3 categories: - <code>txt</code> only: To load raw texts with no pre-annotation - <code>ann</code> only: To load annotations and texts from the same file - <code>ann</code> and <code>txt</code>: To load annotations and texts from two separate files</p> <p>Columns information should be provided via the <code>mapping</code> argument, with the following keys: - \"id\": Column storing a document unique identifier (defaults to \"note_id\"), - \"text\": Column storing the full raw text of the document (defaults to \"note_text\"), - \"label\": Column storing the label name of the entity (defaults to \"label_name\"), - \"attributes\": List of Columns storing attributes to the entity (defaults to []), - \"comments\": Column containing some comments (defaults to \"comment\"), - \"begin\": Column containing the starting position of the entity (defaults to \"offset_begin\"), - \"end\": Column containing the ending position of the entity (defaults to \"offset_end\")</p>"},{"location":"reference/metanno/connectors/pandas/#metanno.connectors.pandas.PandasDataConnector--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>path</code> <p>Path to the folder in which data will be fetched and saved</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>file_type</code> <p>Either <code>csv</code> or <code>pickle</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pickle'</code> </p> <code>redo_initial_prep</code> <p>Whether to re'run the initial data preparation. /!\\ This might overwrite work you've done</p> <p> DEFAULT: <code>False</code> </p> <code>mapping</code> <p>A dictionary of column names</p> <p> TYPE: <code>Dict[str, Any]</code> DEFAULT: <code>DEFAULT_MAPPING</code> </p>"},{"location":"reference/metanno/connectors/pandas/#metanno.connectors.pandas.PandasDataConnector.load_one","title":"<code>load_one</code>","text":"<p>Load annotations coming from a single document</p>"},{"location":"reference/metanno/connectors/pandas/#metanno.connectors.pandas.PandasDataConnector.load_one--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>df</code> <p>Containing annotations from a single document</p> <p> TYPE: <code>DataFrame</code> </p>"},{"location":"reference/metanno/recipes/","title":"<code>metanno.recipes</code>","text":""},{"location":"reference/metanno/recipes/faster_ner/","title":"<code>metanno.recipes.faster_ner</code>","text":""},{"location":"reference/metanno/recipes/ner/","title":"<code>metanno.recipes.ner</code>","text":""},{"location":"reference/metanno/recipes/new_ner/","title":"<code>metanno.recipes.new_ner</code>","text":""},{"location":"reference/pret/ui/metanno/","title":"index.md","text":""},{"location":"reference/pret/ui/metanno/#pretuimetanno","title":"<code>pret.ui.metanno</code>","text":""},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.ImageComponent","title":"<code>ImageComponent</code>","text":"<p>An interactive image viewer that supports drawing, selecting, and styling geometric shapes (polygons, rectangles, points...) as annotations.</p> <p>Under the hood, we use Konva to render the image and its annotations.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.ImageComponent--examples","title":"Examples","text":"<pre><code>from pret import component, proxy, use_tracked, use_event_callback\nfrom pret.ui.metanno import ImageComponent\nimport time\n\n# Reactive store holding the annotation list\nimg_state = proxy([\n    {\n        \"id\": \"1\",\n        \"type\": \"polygon\",\n        \"points\": [10, 10, 50, 20],\n        \"label\": \"OBJ\",\n        \"style\": \"primary\",\n    }\n])\n\n# Style preset referenced from the annotation above\nimg_annotation_styles = {\n    \"primary\": {\n        \"strokeColor\": \"red\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"rgba(255,0,0,0.5)\",\n        \"labelPosition\": \"center\",\n        \"align\": \"center\",\n        \"verticalAlign\": \"top\",\n    },\n    \"secondary\": {\n        \"strokeColor\": \"blue\",\n        \"strokeWidth\": 2,\n        \"fillColor\": \"#0000ff80\",\n        \"textColor\": \"white\",\n    }\n}\n\n@component\ndef MyImage():\n    tracked_state = use_tracked(img_state)\n\n    @use_event_callback\n    def on_mouse_select(modkeys, shapes):\n        # Toggle 'mouseSelected' flag\n        for shp in shapes:\n            img_state.append({\n                \"id\": str(time.time()),\n                \"points\": shp[\"points\"],\n                \"label\": \"OBJ\",\n                \"style\": \"primary\",\n            })\n\n    @use_event_callback\n    def on_click(shape_idx, modkeys):\n        if shape_idx is None:\n            img_state.clear()\n        else:\n            old_style = img_state[shape_idx].get(\"style\", \"primary\")\n            new_style = \"secondary\" if old_style == \"primary\" else \"primary\"\n            img_state[shape_idx][\"style\"] = new_style\n\n    return ImageComponent(\n        image=\"https://picsum.photos/400/300\",\n        annotations=tracked_state,\n        annotation_styles=img_annotation_styles,\n        on_mouse_select=on_mouse_select,\n        on_click=on_click,\n    )\n\nMyImage()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.ImageComponent--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>annotations</code> <p>List of annotation objects drawn on top of the image. Each annotation must contain the geometric <code>type</code> and <code>points</code> fields (defining the shape) plus optional metadata such as:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Human-readable text shown next to the shape.</li> <li><code>style</code>: Key that looks up visual properties in <code>annotation_styles</code>.</li> <li><code>selected</code> / <code>highlighted</code> / <code>mouseSelected</code>: Booleans used by the   component when rendering interaction state.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>annotation_styles</code> <p>Named style presets referenced by the <code>style</code> field of an annotation.  Each preset may define properties such as stroke color, fill color, opacity, font size, and label alignment, using the following properties:</p> <ul> <li><code>strokeColor</code> (str): Color of the shape's stroke (e.g. <code>\"#ff0000\"</code>).</li> <li><code>strokeWidth</code> (int): Width of the shape's stroke in pixels.</li> <li><code>fillColor</code> (str): Background color of the shape (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>opacity</code> (float): Opacity of the shape's fill (0.0 to 1.0).</li> <li><code>shape</code> (str): Shape type, e.g. <code>\"polygon\"</code>, <code>\"rectangle\"</code>, <code>\"circle\"</code>, etc.</li> <li><code>fontSize</code> (int): Font size for the label text.</li> <li><code>align</code> (\"left\" | \"center\" | \"right\"): Horizontal alignment of the label text.</li> <li><code>verticalAlign</code> (\"top\" | \"middle\" | \"bottom\"): Vertical alignment of the label text.</li> </ul> <p> TYPE: <code>Any</code> </p> <code>image</code> <p>Source URL or base-64 data URI of the image to annotate.</p> <p> TYPE: <code>str</code> </p> <code>mouse_selection</code> <p>Temporary shapes being drawn by the user while the mouse button is held down.  Supplied back to <code>on_mouse_select</code> when the gesture ends.</p> <p> TYPE: <code>Any</code> </p> <code>style</code> <p>Inline CSS-compatible style overrides for the root element of the component.</p> <p> TYPE: <code>Any</code> </p> <code>actions</code> <p>Optional imperative handles (e.g. <code>actions[\"scroll_to_shape\"](idx)</code>) that the parent may call.  Reserved for future expansion.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>React key for stable reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click</code> <p>Invoked when the user clicks on an existing shape.</p> <ul> <li><code>shape_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 List of pressed modifier keys (e.g. <code>[\"Shift\"]</code>)</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_key_press</code> <p>Invoked when the component has focus and the user presses a key.</p> <ul> <li><code>key</code> \u2013 The key name (<code>\"Escape\"</code>, <code>\"Delete\"</code> \u2026)</li> <li><code>modkeys</code> \u2013 Concurrently pressed modifier keys</li> </ul> <p> TYPE: <code>Any</code> </p> <code>on_mouse_enter_shape</code> <p>Hover callbacks fired when the mouse pointer enters or leaves a shape.</p> <p> TYPE: <code>Any</code> </p> <code>on_mouse_select</code> <p>Fired after the user completes a drag selection.</p> <ul> <li><code>modkeys</code> \u2013 Modifier keys pressed during selection</li> <li><code>shapes</code> \u2013 All shapes inside the lasso / rectangle</li> </ul> <p> TYPE: <code>Any</code> </p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.TableComponent","title":"<code>TableComponent</code>","text":"<p>A component for displaying a table with various features such as filtering, highlighting rows, and handling cell changes.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.TableComponent--examples","title":"Examples","text":"<pre><code>from pret import component, proxy, use_tracked, use_event_callback\nfrom pret.ui.metanno import TableComponent\n\ntable_state = proxy([\n    {\"id\": \"1\", \"date\": \"2023-01-01\", \"text\": \"Sample text 1\", \"label\": \"ENT\"},\n    {\"id\": \"2\", \"date\": \"2023-01-03\", \"text\": \"Sample text 2\", \"label\": \"OTHER\"},\n    {\"id\": \"3\", \"date\": \"2023-01-05\", \"text\": \"Sample text 3\", \"label\": \"ENT\"},\n    {\"id\": \"4\", \"date\": \"2023-01-07\", \"text\": \"Sample text 4\", \"label\": \"OTHER\"},\n    {\"id\": \"5\", \"date\": \"2023-01-09\", \"text\": \"Sample text 5\", \"label\": \"ENT\"},\n    {\"id\": \"6\", \"date\": \"2023-01-11\", \"text\": \"Sample text 6\", \"label\": \"OTHER\"},\n])\n\ncolumns = [\n    {\"key\": \"id\", \"kind\": \"text\", \"name\": \"id\", \"filterable\": True},\n    {\"key\": \"date\", \"kind\": \"text\", \"name\": \"end\", \"filterable\": True},\n    {\"key\": \"text\", \"kind\": \"text\", \"name\": \"text\", \"filterable\": True, \"editable\": True},\n    {\"key\": \"label\", \"kind\": \"text\", \"name\": \"label\", \"filterable\": True, \"editable\": True, \"choices\": [\"ENT\", \"OTHER\"]},\n]\n\n@component\ndef MyTable():\n    @use_event_callback\n    def on_cell_change(row_idx, col, new_value):\n        table_state[row_idx][col] = new_value\n\n    view_state = use_tracked(table_state)\n    return TableComponent(\n        rows=view_state,\n        columns=columns,\n        auto_filter=True,\n        on_cell_change=on_cell_change,\n    )\n\nMyTable()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.TableComponent--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>columns</code> <p>The columns to display in the table:</p> <ul> <li><code>key</code>: Unique identifier for the column.</li> <li><code>name</code>: Display name of the column.</li> <li><code>kind</code>: Type of data in the column (e.g., \"text\", \"hyperlink\", \"multi-text\", \"boolean\", ...).</li> <li><code>editable</code>: Whether the column is editable.</li> <li><code>filterable</code>: Whether the column can be filtered.</li> <li><code>choices</code>: Optional list of choices for the column (if applicable).</li> </ul> <p> TYPE: <code>ColumnData</code> </p> <code>filters</code> <p>The current filters applied to the table, mapping column keys to filter values.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>highlighted_rows</code> <p>List of row indices that should be highlighted.</p> <p> TYPE: <code>List[int]</code> </p> <code>row_key</code> <p>The key used to uniquely identify each row in the table.</p> <p> TYPE: <code>str</code> </p> <code>rows</code> <p>The data for each row in the table, where each row is a dictionary mapping column keys to their values.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>actions</code> <p>Actions that can be performed on the table, such as scrolling.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>auto_filter</code> <p>Whether to automatically apply filters as the user types.</p> <p> TYPE: <code>bool</code> </p> <code>input_value</code> <p>The current input value to show in the input field when the user is editing a cell. If undefined, this is automatically handled by the component.</p> <p> TYPE: <code>Union[str, Hyperlink]</code> </p> <code>suggestions</code> <p>List of suggestions to show when the user is typing in the input field.</p> <p> TYPE: <code>List[Any]</code> </p> <code>position</code> <p>The current position of the cursor in the table, including:</p> <ul> <li>row_idx: Index of the row where the cursor is located.</li> <li>col: Key of the column where the cursor is located.</li> <li>mode: Mode of interaction, either \"EDIT\" or \"SELECT\".</li> </ul> <p> TYPE: <code>Position</code> </p> <code>style</code> <p>Custom styles for the table component.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>A unique key for the component instance, used for React's reconciliation.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_input_change</code> <p>Callback triggered when the input value changes in a cell. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value entered by the user.</li> <li><code>cause</code>: Reason for the change (e.g., \"blur\", \"enter\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_scroll_bottom</code> <p>Callback triggered when the user scrolls to the bottom of the table. Will be called with the following parameters:</p> <ul> <li><code>event</code>: Scroll event or a dictionary indicating if the user is at the bottom.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_cell_change</code> <p>Callback triggered when a cell's value changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being edited.</li> <li><code>name</code>: Key of the column being edited.</li> <li><code>value</code>: New value of the cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_click_cell_content</code> <p>Callback triggered when the content of a cell is clicked (like a hyperlink). Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row containing the clicked cell.</li> <li><code>name</code>: Key of the column containing the clicked cell.</li> <li><code>value</code>: Optional value of the clicked cell.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_filters_change</code> <p>Callback triggered when filters are updated. Will be called with the following parameters:</p> <ul> <li><code>values</code>: Dictionary mapping column keys to filter values.</li> <li><code>column</code>: Key of the column being filtered.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_enter_row</code> <p>Callback triggered when the mouse enters a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_mouse_leave_row</code> <p>Callback triggered when the mouse leaves a row. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row being hovered.</li> <li><code>mod_keys</code>: List of modifier keys pressed during the event.</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_position_change</code> <p>Callback triggered when the cursor position changes. Will be called with the following parameters:</p> <ul> <li><code>row_idx</code>: Index of the row where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>name</code>: Key of the column where the cursor is located, or <code>None</code> if not applicable.</li> <li><code>mode</code>: Interaction mode, either \"EDIT\" or \"SELECT\".</li> <li><code>cause</code>: Reason for the position change (e.g., \"key\", \"blur\").</li> </ul> <p> TYPE: <code>Callable</code> </p> <code>on_subset_change</code> <p>Callback triggered when the subset of visible rows changes. Will be called with the following parameters:</p> <ul> <li><code>subset</code>: List of indices representing the new subset of rows.</li> </ul> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.TextComponent","title":"<code>TextComponent</code>","text":"<p>The <code>TextComponent</code> is a rich text viewer that supports span-level annotations, nested token highlights, and various user event callbacks.</p>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.TextComponent--examples","title":"Examples","text":"<pre><code>from pret import component, proxy, use_tracked, use_event_callback, use_state\nfrom pret.ui.metanno import TextComponent\nfrom pret.ui.joy import Button, Box\n\ntxt = (\n    \"Metanno brings annotation components to Pret\\n\"\n    \"to build tailored annotation tools.\"\n)\n\n# One span covering the word \u201cMetanno\u201d\nspans = proxy([{\n    \"id\": f\"span-0-7\",\n    \"begin\": 0,\n    \"end\": 7,\n    \"label\": \"OBJ\",\n    \"highlighted\": False,\n}])\n\ntxt_annotation_styles = proxy({\n    \"OBJ\": {\n        \"color\": \"red\",\n        \"shape\": \"underline\",\n    }\n})\n\n@component\ndef MyText():\n    tracked_spans = use_tracked(spans)\n    tracked_styles = use_tracked(txt_annotation_styles)\n\n    @use_event_callback\n    def handle_select(ranges, modkeys):\n        for sp in ranges:\n            spans.extend([\n                {\n                    \"id\": f\"span-{sp['begin']}-{sp['end']}\",\n                    \"begin\": sp[\"begin\"],\n                    \"end\": sp[\"end\"],\n                    \"label\": \"OBJ\",\n                }\n            ])\n\n    def on_mouse_enter_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = True\n\n    def on_mouse_leave_span(span_id, modkeys):\n        for i, sp in enumerate(spans):\n            if sp[\"id\"] == span_id:\n                spans[i][\"highlighted\"] = False\n\n    def on_span_style_change():\n        old_style = txt_annotation_styles[\"OBJ\"][\"shape\"]\n        new_style = \"box\" if old_style == \"underline\" else \"underline\"\n        txt_annotation_styles[\"OBJ\"][\"shape\"] = new_style\n\n    return Box(\n        Button(\"Change style\", on_click=on_span_style_change),\n        Button(\"Remove annotations\", on_click=lambda: spans.clear()),\n        TextComponent(\n            text=txt,\n            spans=tracked_spans,\n            annotation_styles=tracked_styles,\n            on_mouse_select=handle_select,\n            on_mouse_enter_span=on_mouse_enter_span,\n            on_mouse_leave_span=on_mouse_leave_span,\n            style={\"gridColumn\": \"1 / -1\"},\n        ),\n        sx={\"p\": 1, \"display\": \"grid\", \"gridTemplateColumns\": \"repeat(2, auto)\", \"gap\": 1},\n    )\n\nMyText()\n</code></pre>"},{"location":"reference/pret/ui/metanno/#pret.ui.metanno.TextComponent--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>text</code> <p>Raw text content shown in the viewer.</p> <p> TYPE: <code>str</code> </p> <code>spans</code> <p>Span-level annotations over <code>text</code>.  Each span must include <code>begin</code> and <code>end</code> character offsets, with optional fields:</p> <ul> <li><code>id</code>: Optional unique identifier.</li> <li><code>label</code>: Category name displayed next to / above the span.</li> <li><code>style</code>: Key referencing <code>annotation_styles</code>.</li> <li><code>selected</code> (bool): styled as selected by the user.</li> <li><code>highlighted</code> (bool): styled as highlighted by the user.</li> </ul> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>annotation_styles</code> <p>Named style presets that control span background color, border, label placement, etc. Each style may define properties such as:</p> <ul> <li><code>color</code> (str): Color of the span. Will be overridden by <code>backgroundColor</code> and <code>borderColor</code>.</li> <li><code>shape</code> (\"underline\" | \"box\"): Visual style of the span.</li> <li><code>backgroundColor</code> (str): Background color of the span (e.g. <code>\"#0000ff80\"</code>).</li> <li><code>borderColor</code> (str): Border color of the span (e.g. <code>\"#000000\"</code>).</li> <li><code>autoNestingLayout</code> (bool): Whether to automatically nest overlapping spans, rather than rendering them on top of each other.</li> </ul> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> <code>mouse_selection</code> <p>Current mouse drag selection expressed as character\u2010offset ranges. Passed to <code>on_mouse_select</code> when the action completes.</p> <p> TYPE: <code>List[Dict[str, int]]</code> </p> <code>style</code> <p>CSS style overrides for the outer element.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>actions</code> <p>Optional imperative helpers (<code>scroll_to_span</code> \u2026, <code>clear_current_mouse_selection</code>).</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>key</code> <p>React reconciliation key.</p> <p> TYPE: <code>Union[str, int]</code> </p> <code>on_click_span</code> <p>Called when the user clicks on a span.</p> <ul> <li><code>span_id</code> \u2013 Identifier of the clicked annotation</li> <li><code>modkeys</code> \u2013 Pressed modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_key_press</code> <p>Called when a key is pressed with focus inside the component.</p> <ul> <li><code>key</code> \u2013 Key name</li> <li><code>ranges</code> \u2013 Current selection ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[str, List[Dict[str, int]], List[str]], None]</code> </p> <code>on_mouse_enter_span</code> <p>Hover callbacks when entering or leaving a span.</p> <p> TYPE: <code>Callable[[str, List[str]], None]</code> </p> <code>on_mouse_select</code> <p>Triggered when the user finishes selecting text with the mouse.</p> <ul> <li><code>ranges</code> \u2013 Final list of selected ranges</li> <li><code>modkeys</code> \u2013 Modifier keys</li> </ul> <p> TYPE: <code>Callable[[List[Dict[str, int]], List[str]], None]</code> </p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Complete refacto of the framework: the Python-JS synchronized app mechanisms have been moved to a new library: Pret !</li> <li>Text and Table components are now callable directly from python, along other components built around MUI Joy. This gives the user the ability to easily build simple apps, and iterate on the design step by step.</li> <li>Metanno now features new Image annotation component.</li> <li>The tests run in Python 3.7 - 3.10, using playwright in headless Firefox, Chrome and Webkit.</li> <li>Metanno now also has a nice interactive documentation !</li> </ul>"},{"location":"changelog/#metanno-v0","title":"Metanno v0","text":"<p>Metanno v0 is a JupyterLab extension for building custom annotation interfaces. It focuses on textual documents with structured entities and aims for modularity, customization, and interactivity. Core features include multi-line and nested span annotations, table-based relational annotations, multiple data types (hyperlinks, text, lists), and an immutable state that can be synchronized between the frontend and backend. The project compiles Python app classes to JavaScript using Transcrypt, enabling fast, browser-side execution while keeping Python code on the kernel side. To create an app, the user must modify one of the apps in recipes/*.py, and handle state management using a huge Redux-style reducer in <code>select_state</code>.</p> <p>Last items in the v0 changelog:</p> <ul> <li>Almost complete typescript conversion</li> <li>Added column filters</li> <li>Customizable undo/redo logic</li> <li>Editable span annotations from a table view</li> <li>Accessible return value of a Python call from front end (async calls)</li> </ul>"}]}